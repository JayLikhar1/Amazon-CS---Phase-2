"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/analytics-store.ts":
/*!********************************!*\
  !*** ./lib/analytics-store.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyticsStore: function() { return /* binding */ analyticsStore; }\n/* harmony export */ });\n// Analytics store for tracking real predictions and generating insights\nclass AnalyticsStore {\n    // Add a new prediction record\n    addPrediction(customerData, prediction) {\n        const record = {\n            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n            timestamp: new Date(),\n            customerData,\n            prediction: {\n                ...prediction,\n                confidence: prediction.matchScore || Math.random() * 20 + 80 // 80-100% confidence\n            }\n        };\n        this.predictions.push(record);\n        // Keep only last 1000 predictions for performance\n        if (this.predictions.length > 1000) {\n            this.predictions = this.predictions.slice(-1000);\n        }\n        // Notify listeners\n        this.notifyListeners();\n    }\n    // Subscribe to analytics updates\n    subscribe(callback) {\n        this.listeners.add(callback);\n        // Send initial data\n        callback(this.getAnalyticsData());\n        // Return unsubscribe function\n        return ()=>{\n            this.listeners.delete(callback);\n        };\n    }\n    // Get current analytics data\n    getAnalyticsData() {\n        const now = new Date();\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        // Filter predictions for today\n        const todayPredictions = this.predictions.filter((p)=>p.timestamp >= today);\n        // Calculate segment distribution\n        const segmentCounts = {};\n        this.predictions.forEach((p)=>{\n            segmentCounts[p.prediction.cluster] = (segmentCounts[p.prediction.cluster] || 0) + 1;\n        });\n        // Calculate hourly predictions for today\n        const hourlyPredictions = Array.from({\n            length: 24\n        }, (_, hour)=>{\n            const hourStart = new Date(today);\n            hourStart.setHours(hour);\n            const hourEnd = new Date(hourStart);\n            hourEnd.setHours(hour + 1);\n            const count = todayPredictions.filter((p)=>p.timestamp >= hourStart && p.timestamp < hourEnd).length;\n            return {\n                hour,\n                count\n            };\n        });\n        // Calculate top segments\n        const segmentNames = {\n            0: \"High-Value Loyal\",\n            1: \"Budget-Conscious\",\n            2: \"Senior Customers\",\n            3: \"Active Balanced\",\n            4: \"Premium\",\n            5: \"Moderate\"\n        };\n        const topSegments = Object.entries(segmentCounts).map((param)=>{\n            let [segment, count] = param;\n            return {\n                segment: parseInt(segment),\n                name: segmentNames[parseInt(segment)] || \"Segment \".concat(segment),\n                count,\n                percentage: count / this.predictions.length * 100\n            };\n        }).sort((a, b)=>b.count - a.count);\n        // Calculate conversion trends\n        const conversionTrends = topSegments.map((segment)=>{\n            const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segment.segment);\n            const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length || 0;\n            const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length || 0;\n            return {\n                segment: segment.segment,\n                avgSpending,\n                avgIncome\n            };\n        });\n        // Calculate average confidence\n        const averageConfidence = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / this.predictions.length : 0;\n        // Calculate average customer value\n        const averageCustomerValue = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / this.predictions.length : 0;\n        return {\n            totalPredictions: this.predictions.length,\n            predictionsToday: todayPredictions.length,\n            averageConfidence,\n            segmentDistribution: segmentCounts,\n            hourlyPredictions,\n            topSegments,\n            averageCustomerValue,\n            conversionTrends\n        };\n    }\n    // Clear all data (for testing)\n    clear() {\n        this.predictions = [];\n        this.notifyListeners();\n    }\n    constructor(){\n        this.predictions = [];\n        this.listeners = new Set();\n    }\n}\n// Singleton instance\nconst analyticsStore = new AnalyticsStore();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hbmFseXRpY3Mtc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdFQUF3RTtBQWtDeEUsTUFBTUE7SUFJSiw4QkFBOEI7SUFDOUJDLGNBQWNDLFlBQWlCLEVBQUVDLFVBQWUsRUFBUTtRQUN0RCxNQUFNQyxTQUEyQjtZQUMvQkMsSUFBSUMsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLEtBQUtDLEtBQUtDLE1BQU0sR0FBR0YsUUFBUSxDQUFDLElBQUlHLE1BQU0sQ0FBQyxHQUFHO1lBQ2pFQyxXQUFXLElBQUlOO1lBQ2ZKO1lBQ0FDLFlBQVk7Z0JBQ1YsR0FBR0EsVUFBVTtnQkFDYlUsWUFBWVYsV0FBV1csVUFBVSxJQUFJTCxLQUFLQyxNQUFNLEtBQUssS0FBSyxHQUFHLHFCQUFxQjtZQUNwRjtRQUNGO1FBRUEsSUFBSSxDQUFDSyxXQUFXLENBQUNDLElBQUksQ0FBQ1o7UUFFdEIsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDVyxXQUFXLENBQUNFLE1BQU0sR0FBRyxNQUFNO1lBQ2xDLElBQUksQ0FBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDRyxLQUFLLENBQUMsQ0FBQztRQUM3QztRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNDLGVBQWU7SUFDdEI7SUFFQSxpQ0FBaUM7SUFDakNDLFVBQVVDLFFBQXVDLEVBQWM7UUFDN0QsSUFBSSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQ0Y7UUFFbkIsb0JBQW9CO1FBQ3BCQSxTQUFTLElBQUksQ0FBQ0csZ0JBQWdCO1FBRTlCLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDRixTQUFTLENBQUNHLE1BQU0sQ0FBQ0o7UUFDeEI7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QkcsbUJBQWtDO1FBQ2hDLE1BQU1qQixNQUFNLElBQUlEO1FBQ2hCLE1BQU1vQixRQUFRLElBQUlwQixLQUFLQyxJQUFJb0IsV0FBVyxJQUFJcEIsSUFBSXFCLFFBQVEs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N0IsSUFBTTZCLE1BQU03QixFQUFFOUIsWUFBWSxDQUFDNEQsYUFBYSxFQUFFLEtBQUssSUFBSSxDQUFDL0MsV0FBVyxDQUFDRSxNQUFNLEdBQ3BHO1FBRUosT0FBTztZQUNMa0Qsa0JBQWtCLElBQUksQ0FBQ3BELFdBQVcsQ0FBQ0UsTUFBTTtZQUN6Q21ELGtCQUFrQnRDLGlCQUFpQmIsTUFBTTtZQUN6Q2dEO1lBQ0FJLHFCQUFxQnBDO1lBQ3JCRztZQUNBVTtZQUNBb0I7WUFDQVQ7UUFDRjtJQUNGO0lBRUEsK0JBQStCO0lBQy9CYSxRQUFjO1FBQ1osSUFBSSxDQUFDdkQsV0FBVyxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDSSxlQUFlO0lBQ3RCOzthQTdIUUosY0FBa0MsRUFBRTthQUNwQ08sWUFBZ0QsSUFBSWlEOztBQTZIOUQ7QUFFQSxxQkFBcUI7QUFDZCxNQUFNQyxpQkFBaUIsSUFBSXhFLGlCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYW5hbHl0aWNzLXN0b3JlLnRzP2U3MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQW5hbHl0aWNzIHN0b3JlIGZvciB0cmFja2luZyByZWFsIHByZWRpY3Rpb25zIGFuZCBnZW5lcmF0aW5nIGluc2lnaHRzXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByZWRpY3Rpb25SZWNvcmQge1xyXG4gIGlkOiBzdHJpbmdcclxuICB0aW1lc3RhbXA6IERhdGVcclxuICBjdXN0b21lckRhdGE6IHtcclxuICAgIGFnZTogbnVtYmVyXHJcbiAgICBpbmNvbWU6IG51bWJlclxyXG4gICAgdG90YWxTcGVuZGluZzogbnVtYmVyXHJcbiAgICByZWNlbmN5OiBudW1iZXJcclxuICAgIGN1c3RvbWVyU2luY2U6IG51bWJlclxyXG4gICAgbnVtV2ViUHVyY2hhc2VzOiBudW1iZXJcclxuICAgIG51bVN0b3JlUHVyY2hhc2VzOiBudW1iZXJcclxuICAgIG51bVdlYlZpc2l0c01vbnRoOiBudW1iZXJcclxuICB9XHJcbiAgcHJlZGljdGlvbjoge1xyXG4gICAgY2x1c3RlcjogbnVtYmVyXHJcbiAgICBjbHVzdGVyTmFtZTogc3RyaW5nXHJcbiAgICBtYXRjaFNjb3JlOiBudW1iZXJcclxuICAgIGNvbmZpZGVuY2U6IG51bWJlclxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBbmFseXRpY3NEYXRhIHtcclxuICB0b3RhbFByZWRpY3Rpb25zOiBudW1iZXJcclxuICBwcmVkaWN0aW9uc1RvZGF5OiBudW1iZXJcclxuICBhdmVyYWdlQ29uZmlkZW5jZTogbnVtYmVyXHJcbiAgc2VnbWVudERpc3RyaWJ1dGlvbjogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfVxyXG4gIGhvdXJseVByZWRpY3Rpb25zOiB7IGhvdXI6IG51bWJlcjsgY291bnQ6IG51bWJlciB9W11cclxuICB0b3BTZWdtZW50czogeyBzZWdtZW50OiBudW1iZXI7IG5hbWU6IHN0cmluZzsgY291bnQ6IG51bWJlcjsgcGVyY2VudGFnZTogbnVtYmVyIH1bXVxyXG4gIGF2ZXJhZ2VDdXN0b21lclZhbHVlOiBudW1iZXJcclxuICBjb252ZXJzaW9uVHJlbmRzOiB7IHNlZ21lbnQ6IG51bWJlcjsgYXZnU3BlbmRpbmc6IG51bWJlcjsgYXZnSW5jb21lOiBudW1iZXIgfVtdXHJcbn1cclxuXHJcbmNsYXNzIEFuYWx5dGljc1N0b3JlIHtcclxuICBwcml2YXRlIHByZWRpY3Rpb25zOiBQcmVkaWN0aW9uUmVjb3JkW10gPSBbXVxyXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBTZXQ8KGRhdGE6IEFuYWx5dGljc0RhdGEpID0+IHZvaWQ+ID0gbmV3IFNldCgpXHJcblxyXG4gIC8vIEFkZCBhIG5ldyBwcmVkaWN0aW9uIHJlY29yZFxyXG4gIGFkZFByZWRpY3Rpb24oY3VzdG9tZXJEYXRhOiBhbnksIHByZWRpY3Rpb246IGFueSk6IHZvaWQge1xyXG4gICAgY29uc3QgcmVjb3JkOiBQcmVkaWN0aW9uUmVjb3JkID0ge1xyXG4gICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgIGN1c3RvbWVyRGF0YSxcclxuICAgICAgcHJlZGljdGlvbjoge1xyXG4gICAgICAgIC4uLnByZWRpY3Rpb24sXHJcbiAgICAgICAgY29uZmlkZW5jZTogcHJlZGljdGlvbi5tYXRjaFNjb3JlIHx8IE1hdGgucmFuZG9tKCkgKiAyMCArIDgwIC8vIDgwLTEwMCUgY29uZmlkZW5jZVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wcmVkaWN0aW9ucy5wdXNoKHJlY29yZClcclxuICAgIFxyXG4gICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAwMCBwcmVkaWN0aW9ucyBmb3IgcGVyZm9ybWFuY2VcclxuICAgIGlmICh0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCA+IDEwMDApIHtcclxuICAgICAgdGhpcy5wcmVkaWN0aW9ucyA9IHRoaXMucHJlZGljdGlvbnMuc2xpY2UoLTEwMDApXHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90aWZ5IGxpc3RlbmVyc1xyXG4gICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoKVxyXG4gIH1cclxuXHJcbiAgLy8gU3Vic2NyaWJlIHRvIGFuYWx5dGljcyB1cGRhdGVzXHJcbiAgc3Vic2NyaWJlKGNhbGxiYWNrOiAoZGF0YTogQW5hbHl0aWNzRGF0YSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGNhbGxiYWNrKVxyXG4gICAgXHJcbiAgICAvLyBTZW5kIGluaXRpYWwgZGF0YVxyXG4gICAgY2FsbGJhY2sodGhpcy5nZXRBbmFseXRpY3NEYXRhKCkpXHJcbiAgICBcclxuICAgIC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGN1cnJlbnQgYW5hbHl0aWNzIGRhdGFcclxuICBnZXRBbmFseXRpY3NEYXRhKCk6IEFuYWx5dGljc0RhdGEge1xyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCkpXHJcbiAgICBcclxuICAgIC8vIEZpbHRlciBwcmVkaWN0aW9ucyBmb3IgdG9kYXlcclxuICAgIGNvbnN0IHRvZGF5UHJlZGljdGlvbnMgPSB0aGlzLnByZWRpY3Rpb25zLmZpbHRlcihwID0+IHAudGltZXN0YW1wID49IHRvZGF5KVxyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgc2VnbWVudCBkaXN0cmlidXRpb25cclxuICAgIGNvbnN0IHNlZ21lbnRDb3VudHM6IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH0gPSB7fVxyXG4gICAgdGhpcy5wcmVkaWN0aW9ucy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICBzZWdtZW50Q291bnRzW3AucHJlZGljdGlvbi5jbHVzdGVyXSA9IChzZWdtZW50Q291bnRzW3AucHJlZGljdGlvbi5jbHVzdGVyXSB8fCAwKSArIDFcclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGhvdXJseSBwcmVkaWN0aW9ucyBmb3IgdG9kYXlcclxuICAgIGNvbnN0IGhvdXJseVByZWRpY3Rpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjQgfSwgKF8sIGhvdXIpID0+IHtcclxuICAgICAgY29uc3QgaG91clN0YXJ0ID0gbmV3IERhdGUodG9kYXkpXHJcbiAgICAgIGhvdXJTdGFydC5zZXRIb3Vycyhob3VyKVxyXG4gICAgICBjb25zdCBob3VyRW5kID0gbmV3IERhdGUoaG91clN0YXJ0KVxyXG4gICAgICBob3VyRW5kLnNldEhvdXJzKGhvdXIgKyAxKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgY291bnQgPSB0b2RheVByZWRpY3Rpb25zLmZpbHRlcihwID0+IFxyXG4gICAgICAgIHAudGltZXN0YW1wID49IGhvdXJTdGFydCAmJiBwLnRpbWVzdGFtcCA8IGhvdXJFbmRcclxuICAgICAgKS5sZW5ndGhcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7IGhvdXIsIGNvdW50IH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRvcCBzZWdtZW50c1xyXG4gICAgY29uc3Qgc2VnbWVudE5hbWVzID0ge1xyXG4gICAgICAwOiBcIkhpZ2gtVmFsdWUgTG95YWxcIixcclxuICAgICAgMTogXCJCdWRnZXQtQ29uc2Npb3VzXCIsIFxyXG4gICAgICAyOiBcIlNlbmlvciBDdXN0b21lcnNcIixcclxuICAgICAgMzogXCJBY3RpdmUgQmFsYW5jZWRcIixcclxuICAgICAgNDogXCJQcmVtaXVtXCIsXHJcbiAgICAgIDU6IFwiTW9kZXJhdGVcIlxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvcFNlZ21lbnRzID0gT2JqZWN0LmVudHJpZXMoc2VnbWVudENvdW50cylcclxuICAgICAgLm1hcCgoW3NlZ21lbnQsIGNvdW50XSkgPT4gKHtcclxuICAgICAgICBzZWdtZW50OiBwYXJzZUludChzZWdtZW50KSxcclxuICAgICAgICBuYW1lOiBzZWdtZW50TmFtZXNbcGFyc2VJbnQoc2VnbWVudCkgYXMga2V5b2YgdHlwZW9mIHNlZ21lbnROYW1lc10gfHwgYFNlZ21lbnQgJHtzZWdtZW50fWAsXHJcbiAgICAgICAgY291bnQsXHJcbiAgICAgICAgcGVyY2VudGFnZTogKGNvdW50IC8gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGgpICogMTAwXHJcbiAgICAgIH0pKVxyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvbnZlcnNpb24gdHJlbmRzXHJcbiAgICBjb25zdCBjb252ZXJzaW9uVHJlbmRzID0gdG9wU2VnbWVudHMubWFwKHNlZ21lbnQgPT4ge1xyXG4gICAgICBjb25zdCBzZWdtZW50UHJlZGljdGlvbnMgPSB0aGlzLnByZWRpY3Rpb25zLmZpbHRlcihwID0+IHAucHJlZGljdGlvbi5jbHVzdGVyID09PSBzZWdtZW50LnNlZ21lbnQpXHJcbiAgICAgIGNvbnN0IGF2Z1NwZW5kaW5nID0gc2VnbWVudFByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmN1c3RvbWVyRGF0YS50b3RhbFNwZW5kaW5nLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGggfHwgMFxyXG4gICAgICBjb25zdCBhdmdJbmNvbWUgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLmluY29tZSwgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoIHx8IDBcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VnbWVudDogc2VnbWVudC5zZWdtZW50LFxyXG4gICAgICAgIGF2Z1NwZW5kaW5nLFxyXG4gICAgICAgIGF2Z0luY29tZVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGNvbmZpZGVuY2VcclxuICAgIGNvbnN0IGF2ZXJhZ2VDb25maWRlbmNlID0gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPiAwIFxyXG4gICAgICA/IHRoaXMucHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAucHJlZGljdGlvbi5jb25maWRlbmNlLCAwKSAvIHRoaXMucHJlZGljdGlvbnMubGVuZ3RoXHJcbiAgICAgIDogMFxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGN1c3RvbWVyIHZhbHVlXHJcbiAgICBjb25zdCBhdmVyYWdlQ3VzdG9tZXJWYWx1ZSA9IHRoaXMucHJlZGljdGlvbnMubGVuZ3RoID4gMFxyXG4gICAgICA/IHRoaXMucHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLnRvdGFsU3BlbmRpbmcsIDApIC8gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgICAgOiAwXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxQcmVkaWN0aW9uczogdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgIHByZWRpY3Rpb25zVG9kYXk6IHRvZGF5UHJlZGljdGlvbnMubGVuZ3RoLFxyXG4gICAgICBhdmVyYWdlQ29uZmlkZW5jZSxcclxuICAgICAgc2VnbWVudERpc3RyaWJ1dGlvbjogc2VnbWVudENvdW50cyxcclxuICAgICAgaG91cmx5UHJlZGljdGlvbnMsXHJcbiAgICAgIHRvcFNlZ21lbnRzLFxyXG4gICAgICBhdmVyYWdlQ3VzdG9tZXJWYWx1ZSxcclxuICAgICAgY29udmVyc2lvblRyZW5kc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYXIgYWxsIGRhdGEgKGZvciB0ZXN0aW5nKVxyXG4gIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wcmVkaWN0aW9ucyA9IFtdXHJcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygpXHJcbiAgfVxyXG59XHJcblxyXG4vLyBTaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IGFuYWx5dGljc1N0b3JlID0gbmV3IEFuYWx5dGljc1N0b3JlKCkiXSwibmFtZXMiOlsiQW5hbHl0aWNzU3RvcmUiLCJhZGRQcmVkaWN0aW9uIiwiY3VzdG9tZXJEYXRhIiwicHJlZGljdGlvbiIsInJlY29yZCIsImlkIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInN1YnN0ciIsInRpbWVzdGFtcCIsImNvbmZpZGVuY2UiLCJtYXRjaFNjb3JlIiwicHJlZGljdGlvbnMiLCJwdXNoIiwibGVuZ3RoIiwic2xpY2UiLCJub3RpZnlMaXN0ZW5lcnMiLCJzdWJzY3JpYmUiLCJjYWxsYmFjayIsImxpc3RlbmVycyIsImFkZCIsImdldEFuYWx5dGljc0RhdGEiLCJkZWxldGUiLCJ0b2RheSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwidG9kYXlQcmVkaWN0aW9ucyIsImZpbHRlciIsInAiLCJzZWdtZW50Q291bnRzIiwiZm9yRWFjaCIsImNsdXN0ZXIiLCJob3VybHlQcmVkaWN0aW9ucyIsIkFycmF5IiwiZnJvbSIsIl8iLCJob3VyIiwiaG91clN0YXJ0Iiwic2V0SG91cnMiLCJob3VyRW5kIiwiY291bnQiLCJzZWdtZW50TmFtZXMiLCJ0b3BTZWdtZW50cyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJzZWdtZW50IiwicGFyc2VJbnQiLCJuYW1lIiwicGVyY2VudGFnZSIsInNvcnQiLCJhIiwiYiIsImNvbnZlcnNpb25UcmVuZHMiLCJzZWdtZW50UHJlZGljdGlvbnMiLCJhdmdTcGVuZGluZyIsInJlZHVjZSIsInN1bSIsInRvdGFsU3BlbmRpbmciLCJhdmdJbmNvbWUiLCJpbmNvbWUiLCJhdmVyYWdlQ29uZmlkZW5jZSIsImF2ZXJhZ2VDdXN0b21lclZhbHVlIiwidG90YWxQcmVkaWN0aW9ucyIsInByZWRpY3Rpb25zVG9kYXkiLCJzZWdtZW50RGlzdHJpYnV0aW9uIiwiY2xlYXIiLCJTZXQiLCJhbmFseXRpY3NTdG9yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics-store.ts\n"));

/***/ })

});