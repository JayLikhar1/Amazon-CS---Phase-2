"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/analytics-store.ts":
/*!********************************!*\
  !*** ./lib/analytics-store.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyticsStore: function() { return /* binding */ analyticsStore; }\n/* harmony export */ });\n// Analytics store for tracking real predictions and generating insights\nclass AnalyticsStore {\n    // Add a new prediction record\n    addPrediction(customerData, prediction) {\n        const record = {\n            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n            timestamp: new Date(),\n            customerData,\n            prediction: {\n                ...prediction,\n                confidence: prediction.matchScore || Math.random() * 20 + 80 // 80-100% confidence\n            }\n        };\n        this.predictions.push(record);\n        // Keep only last 1000 predictions for performance\n        if (this.predictions.length > 1000) {\n            this.predictions = this.predictions.slice(-1000);\n        }\n        // Notify listeners\n        this.notifyListeners();\n    }\n    // Subscribe to analytics updates\n    subscribe(callback) {\n        this.listeners.add(callback);\n        // Send initial data\n        callback(this.getAnalyticsData());\n        // Return unsubscribe function\n        return ()=>{\n            this.listeners.delete(callback);\n        };\n    }\n    // Get current analytics data\n    getAnalyticsData() {\n        const now = new Date();\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        // Filter predictions for today\n        const todayPredictions = this.predictions.filter((p)=>p.timestamp >= today);\n        // Calculate segment distribution\n        const segmentCounts = {};\n        this.predictions.forEach((p)=>{\n            segmentCounts[p.prediction.cluster] = (segmentCounts[p.prediction.cluster] || 0) + 1;\n        });\n        // Calculate hourly predictions for today\n        const hourlyPredictions = Array.from({\n            length: 24\n        }, (_, hour)=>{\n            const hourStart = new Date(today);\n            hourStart.setHours(hour);\n            const hourEnd = new Date(hourStart);\n            hourEnd.setHours(hour + 1);\n            const count = todayPredictions.filter((p)=>p.timestamp >= hourStart && p.timestamp < hourEnd).length;\n            return {\n                hour,\n                count\n            };\n        });\n        // Calculate top segments\n        const segmentNames = {\n            0: \"High-Value Loyal\",\n            1: \"Budget-Conscious\",\n            2: \"Senior Customers\",\n            3: \"Active Balanced\",\n            4: \"Premium\",\n            5: \"Moderate\"\n        };\n        const topSegments = Object.entries(segmentCounts).map((param)=>{\n            let [segment, count] = param;\n            return {\n                segment: parseInt(segment),\n                name: segmentNames[parseInt(segment)] || \"Segment \".concat(segment),\n                count,\n                percentage: count / this.predictions.length * 100\n            };\n        }).sort((a, b)=>b.count - a.count);\n        // Calculate conversion trends\n        const conversionTrends = topSegments.map((segment)=>{\n            const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segment.segment);\n            const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length || 0;\n            const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length || 0;\n            return {\n                segment: segment.segment,\n                avgSpending,\n                avgIncome\n            };\n        });\n        // Calculate average confidence\n        const averageConfidence = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / this.predictions.length : 0;\n        // Calculate average customer value\n        const averageCustomerValue = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / this.predictions.length : 0;\n        return {\n            totalPredictions: this.predictions.length,\n            predictionsToday: todayPredictions.length,\n            averageConfidence,\n            segmentDistribution: segmentCounts,\n            hourlyPredictions,\n            topSegments,\n            averageCustomerValue,\n            conversionTrends\n        };\n    }\n    // Clear all data (for testing)\n    clear() {\n        this.predictions = [];\n        this.notifyListeners();\n    }\n    notifyListeners() {\n        const data = this.getAnalyticsData();\n        this.listeners.forEach((callback)=>callback(data));\n    }\n    // Get predictions for a specific time range\n    getPredictionsInRange(startDate, endDate) {\n        return this.predictions.filter((p)=>p.timestamp >= startDate && p.timestamp <= endDate);\n    }\n    // Get segment performance metrics\n    getSegmentMetrics(segmentId) {\n        const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segmentId);\n        if (segmentPredictions.length === 0) {\n            return null;\n        }\n        const avgConfidence = segmentPredictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / segmentPredictions.length;\n        const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length;\n        const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length;\n        const avgAge = segmentPredictions.reduce((sum, p)=>sum + p.customerData.age, 0) / segmentPredictions.length;\n        return {\n            count: segmentPredictions.length,\n            avgConfidence,\n            avgSpending,\n            avgIncome,\n            avgAge,\n            recentPredictions: segmentPredictions.slice(-5)\n        };\n    }\n    constructor(){\n        this.predictions = [];\n        this.listeners = new Set();\n    }\n}\n// Singleton instance\nconst analyticsStore = new AnalyticsStore();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hbmFseXRpY3Mtc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdFQUF3RTtBQWtDeEUsTUFBTUE7SUFJSiw4QkFBOEI7SUFDOUJDLGNBQWNDLFlBQWlCLEVBQUVDLFVBQWUsRUFBUTtRQUN0RCxNQUFNQyxTQUEyQjtZQUMvQkMsSUFBSUMsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLEtBQUtDLEtBQUtDLE1BQU0sR0FBR0YsUUFBUSxDQUFDLElBQUlHLE1BQU0sQ0FBQyxHQUFHO1lBQ2pFQyxXQUFXLElBQUlOO1lBQ2ZKO1lBQ0FDLFlBQVk7Z0JBQ1YsR0FBR0EsVUFBVTtnQkFDYlUsWUFBWVYsV0FBV1csVUFBVSxJQUFJTCxLQUFLQyxNQUFNLEtBQUssS0FBSyxHQUFHLHFCQUFxQjtZQUNwRjtRQUNGO1FBRUEsSUFBSSxDQUFDSyxXQUFXLENBQUNDLElBQUksQ0FBQ1o7UUFFdEIsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDVyxXQUFXLENBQUNFLE1BQU0sR0FBRyxNQUFNO1lBQ2xDLElBQUksQ0FBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDRyxLQUFLLENBQUMsQ0FBQztRQUM3QztRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNDLGVBQWU7SUFDdEI7SUFFQSxpQ0FBaUM7SUFDakNDLFVBQVVDLFFBQXVDLEVBQWM7UUFDN0QsSUFBSSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQ0Y7UUFFbkIsb0JBQW9CO1FBQ3BCQSxTQUFTLElBQUksQ0FBQ0csZ0JBQWdCO1FBRTlCLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDRixTQUFTLENBQUNHLE1BQU0sQ0FBQ0o7UUFDeEI7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QkcsbUJBQWtDO1FBQ2hDLE1BQU1qQixNQUFNLElBQUlEO1FBQ2hCLE1BQU1vQixRQUFRLElBQUlwQixLQUFLQyxJQUFJb0IsV0FBVyxJQUFJcEIsSUFBSXFCLFFBQVEs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Y0FBY0QsbUJBQW1CRSxNQUFNLENBQUMsQ0FBQ0MsS0FBSzdCLElBQU02QixNQUFNN0IsRUFBRTlCLFlBQVksQ0FBQzRELGFBQWEsRUFBRSxLQUFLSixtQkFBbUJ6QyxNQUFNO1FBQzVILE1BQU04QyxZQUFZTCxtQkFBbUJFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLN0IsSUFBTTZCLE1BQU03QixFQUFFOUIsWUFBWSxDQUFDOEQsTUFBTSxFQUFFLEtBQUtOLG1CQUFtQnpDLE1BQU07UUFDbkgsTUFBTTZELFNBQVNwQixtQkFBbUJFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLN0IsSUFBTTZCLE1BQU03QixFQUFFOUIsWUFBWSxDQUFDNkUsR0FBRyxFQUFFLEtBQUtyQixtQkFBbUJ6QyxNQUFNO1FBRTdHLE9BQU87WUFDTDJCLE9BQU9jLG1CQUFtQnpDLE1BQU07WUFDaEM0RDtZQUNBbEI7WUFDQUk7WUFDQWU7WUFDQUUsbUJBQW1CdEIsbUJBQW1CeEMsS0FBSyxDQUFDLENBQUM7UUFDL0M7SUFDRjs7YUFoS1FILGNBQWtDLEVBQUU7YUFDcENPLFlBQWdELElBQUkyRDs7QUFnSzlEO0FBRUEscUJBQXFCO0FBQ2QsTUFBTUMsaUJBQWlCLElBQUlsRixpQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FuYWx5dGljcy1zdG9yZS50cz9lNzMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFuYWx5dGljcyBzdG9yZSBmb3IgdHJhY2tpbmcgcmVhbCBwcmVkaWN0aW9ucyBhbmQgZ2VuZXJhdGluZyBpbnNpZ2h0c1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcmVkaWN0aW9uUmVjb3JkIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBEYXRlXHJcbiAgY3VzdG9tZXJEYXRhOiB7XHJcbiAgICBhZ2U6IG51bWJlclxyXG4gICAgaW5jb21lOiBudW1iZXJcclxuICAgIHRvdGFsU3BlbmRpbmc6IG51bWJlclxyXG4gICAgcmVjZW5jeTogbnVtYmVyXHJcbiAgICBjdXN0b21lclNpbmNlOiBudW1iZXJcclxuICAgIG51bVdlYlB1cmNoYXNlczogbnVtYmVyXHJcbiAgICBudW1TdG9yZVB1cmNoYXNlczogbnVtYmVyXHJcbiAgICBudW1XZWJWaXNpdHNNb250aDogbnVtYmVyXHJcbiAgfVxyXG4gIHByZWRpY3Rpb246IHtcclxuICAgIGNsdXN0ZXI6IG51bWJlclxyXG4gICAgY2x1c3Rlck5hbWU6IHN0cmluZ1xyXG4gICAgbWF0Y2hTY29yZTogbnVtYmVyXHJcbiAgICBjb25maWRlbmNlOiBudW1iZXJcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQW5hbHl0aWNzRGF0YSB7XHJcbiAgdG90YWxQcmVkaWN0aW9uczogbnVtYmVyXHJcbiAgcHJlZGljdGlvbnNUb2RheTogbnVtYmVyXHJcbiAgYXZlcmFnZUNvbmZpZGVuY2U6IG51bWJlclxyXG4gIHNlZ21lbnREaXN0cmlidXRpb246IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH1cclxuICBob3VybHlQcmVkaWN0aW9uczogeyBob3VyOiBudW1iZXI7IGNvdW50OiBudW1iZXIgfVtdXHJcbiAgdG9wU2VnbWVudHM6IHsgc2VnbWVudDogbnVtYmVyOyBuYW1lOiBzdHJpbmc7IGNvdW50OiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9W11cclxuICBhdmVyYWdlQ3VzdG9tZXJWYWx1ZTogbnVtYmVyXHJcbiAgY29udmVyc2lvblRyZW5kczogeyBzZWdtZW50OiBudW1iZXI7IGF2Z1NwZW5kaW5nOiBudW1iZXI7IGF2Z0luY29tZTogbnVtYmVyIH1bXVxyXG59XHJcblxyXG5jbGFzcyBBbmFseXRpY3NTdG9yZSB7XHJcbiAgcHJpdmF0ZSBwcmVkaWN0aW9uczogUHJlZGljdGlvblJlY29yZFtdID0gW11cclxuICBwcml2YXRlIGxpc3RlbmVyczogU2V0PChkYXRhOiBBbmFseXRpY3NEYXRhKSA9PiB2b2lkPiA9IG5ldyBTZXQoKVxyXG5cclxuICAvLyBBZGQgYSBuZXcgcHJlZGljdGlvbiByZWNvcmRcclxuICBhZGRQcmVkaWN0aW9uKGN1c3RvbWVyRGF0YTogYW55LCBwcmVkaWN0aW9uOiBhbnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IHJlY29yZDogUHJlZGljdGlvblJlY29yZCA9IHtcclxuICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICBjdXN0b21lckRhdGEsXHJcbiAgICAgIHByZWRpY3Rpb246IHtcclxuICAgICAgICAuLi5wcmVkaWN0aW9uLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IHByZWRpY3Rpb24ubWF0Y2hTY29yZSB8fCBNYXRoLnJhbmRvbSgpICogMjAgKyA4MCAvLyA4MC0xMDAlIGNvbmZpZGVuY2VcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJlZGljdGlvbnMucHVzaChyZWNvcmQpXHJcbiAgICBcclxuICAgIC8vIEtlZXAgb25seSBsYXN0IDEwMDAgcHJlZGljdGlvbnMgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICBpZiAodGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPiAxMDAwKSB7XHJcbiAgICAgIHRoaXMucHJlZGljdGlvbnMgPSB0aGlzLnByZWRpY3Rpb25zLnNsaWNlKC0xMDAwKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnNcclxuICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKClcclxuICB9XHJcblxyXG4gIC8vIFN1YnNjcmliZSB0byBhbmFseXRpY3MgdXBkYXRlc1xyXG4gIHN1YnNjcmliZShjYWxsYmFjazogKGRhdGE6IEFuYWx5dGljc0RhdGEpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcclxuICAgIHRoaXMubGlzdGVuZXJzLmFkZChjYWxsYmFjaylcclxuICAgIFxyXG4gICAgLy8gU2VuZCBpbml0aWFsIGRhdGFcclxuICAgIGNhbGxiYWNrKHRoaXMuZ2V0QW5hbHl0aWNzRGF0YSgpKVxyXG4gICAgXHJcbiAgICAvLyBSZXR1cm4gdW5zdWJzY3JpYmUgZnVuY3Rpb25cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjaylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEdldCBjdXJyZW50IGFuYWx5dGljcyBkYXRhXHJcbiAgZ2V0QW5hbHl0aWNzRGF0YSgpOiBBbmFseXRpY3NEYXRhIHtcclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcclxuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpKVxyXG4gICAgXHJcbiAgICAvLyBGaWx0ZXIgcHJlZGljdGlvbnMgZm9yIHRvZGF5XHJcbiAgICBjb25zdCB0b2RheVByZWRpY3Rpb25zID0gdGhpcy5wcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBwLnRpbWVzdGFtcCA+PSB0b2RheSlcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIHNlZ21lbnQgZGlzdHJpYnV0aW9uXHJcbiAgICBjb25zdCBzZWdtZW50Q291bnRzOiB7IFtrZXk6IG51bWJlcl06IG51bWJlciB9ID0ge31cclxuICAgIHRoaXMucHJlZGljdGlvbnMuZm9yRWFjaChwID0+IHtcclxuICAgICAgc2VnbWVudENvdW50c1twLnByZWRpY3Rpb24uY2x1c3Rlcl0gPSAoc2VnbWVudENvdW50c1twLnByZWRpY3Rpb24uY2x1c3Rlcl0gfHwgMCkgKyAxXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBob3VybHkgcHJlZGljdGlvbnMgZm9yIHRvZGF5XHJcbiAgICBjb25zdCBob3VybHlQcmVkaWN0aW9ucyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI0IH0sIChfLCBob3VyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGhvdXJTdGFydCA9IG5ldyBEYXRlKHRvZGF5KVxyXG4gICAgICBob3VyU3RhcnQuc2V0SG91cnMoaG91cilcclxuICAgICAgY29uc3QgaG91ckVuZCA9IG5ldyBEYXRlKGhvdXJTdGFydClcclxuICAgICAgaG91ckVuZC5zZXRIb3Vycyhob3VyICsgMSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNvdW50ID0gdG9kYXlQcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBcclxuICAgICAgICBwLnRpbWVzdGFtcCA+PSBob3VyU3RhcnQgJiYgcC50aW1lc3RhbXAgPCBob3VyRW5kXHJcbiAgICAgICkubGVuZ3RoXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4geyBob3VyLCBjb3VudCB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0b3Agc2VnbWVudHNcclxuICAgIGNvbnN0IHNlZ21lbnROYW1lcyA9IHtcclxuICAgICAgMDogXCJIaWdoLVZhbHVlIExveWFsXCIsXHJcbiAgICAgIDE6IFwiQnVkZ2V0LUNvbnNjaW91c1wiLCBcclxuICAgICAgMjogXCJTZW5pb3IgQ3VzdG9tZXJzXCIsXHJcbiAgICAgIDM6IFwiQWN0aXZlIEJhbGFuY2VkXCIsXHJcbiAgICAgIDQ6IFwiUHJlbWl1bVwiLFxyXG4gICAgICA1OiBcIk1vZGVyYXRlXCJcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b3BTZWdtZW50cyA9IE9iamVjdC5lbnRyaWVzKHNlZ21lbnRDb3VudHMpXHJcbiAgICAgIC5tYXAoKFtzZWdtZW50LCBjb3VudF0pID0+ICh7XHJcbiAgICAgICAgc2VnbWVudDogcGFyc2VJbnQoc2VnbWVudCksXHJcbiAgICAgICAgbmFtZTogc2VnbWVudE5hbWVzW3BhcnNlSW50KHNlZ21lbnQpIGFzIGtleW9mIHR5cGVvZiBzZWdtZW50TmFtZXNdIHx8IGBTZWdtZW50ICR7c2VnbWVudH1gLFxyXG4gICAgICAgIGNvdW50LFxyXG4gICAgICAgIHBlcmNlbnRhZ2U6IChjb3VudCAvIHRoaXMucHJlZGljdGlvbnMubGVuZ3RoKSAqIDEwMFxyXG4gICAgICB9KSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBjb252ZXJzaW9uIHRyZW5kc1xyXG4gICAgY29uc3QgY29udmVyc2lvblRyZW5kcyA9IHRvcFNlZ21lbnRzLm1hcChzZWdtZW50ID0+IHtcclxuICAgICAgY29uc3Qgc2VnbWVudFByZWRpY3Rpb25zID0gdGhpcy5wcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBwLnByZWRpY3Rpb24uY2x1c3RlciA9PT0gc2VnbWVudC5zZWdtZW50KVxyXG4gICAgICBjb25zdCBhdmdTcGVuZGluZyA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEudG90YWxTcGVuZGluZywgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoIHx8IDBcclxuICAgICAgY29uc3QgYXZnSW5jb21lID0gc2VnbWVudFByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmN1c3RvbWVyRGF0YS5pbmNvbWUsIDApIC8gc2VnbWVudFByZWRpY3Rpb25zLmxlbmd0aCB8fCAwXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlZ21lbnQ6IHNlZ21lbnQuc2VnbWVudCxcclxuICAgICAgICBhdmdTcGVuZGluZyxcclxuICAgICAgICBhdmdJbmNvbWVcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSBjb25maWRlbmNlXHJcbiAgICBjb25zdCBhdmVyYWdlQ29uZmlkZW5jZSA9IHRoaXMucHJlZGljdGlvbnMubGVuZ3RoID4gMCBcclxuICAgICAgPyB0aGlzLnByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnByZWRpY3Rpb24uY29uZmlkZW5jZSwgMCkgLyB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aFxyXG4gICAgICA6IDBcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSBjdXN0b21lciB2YWx1ZVxyXG4gICAgY29uc3QgYXZlcmFnZUN1c3RvbWVyVmFsdWUgPSB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCA+IDBcclxuICAgICAgPyB0aGlzLnByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmN1c3RvbWVyRGF0YS50b3RhbFNwZW5kaW5nLCAwKSAvIHRoaXMucHJlZGljdGlvbnMubGVuZ3RoXHJcbiAgICAgIDogMFxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvdGFsUHJlZGljdGlvbnM6IHRoaXMucHJlZGljdGlvbnMubGVuZ3RoLFxyXG4gICAgICBwcmVkaWN0aW9uc1RvZGF5OiB0b2RheVByZWRpY3Rpb25zLmxlbmd0aCxcclxuICAgICAgYXZlcmFnZUNvbmZpZGVuY2UsXHJcbiAgICAgIHNlZ21lbnREaXN0cmlidXRpb246IHNlZ21lbnRDb3VudHMsXHJcbiAgICAgIGhvdXJseVByZWRpY3Rpb25zLFxyXG4gICAgICB0b3BTZWdtZW50cyxcclxuICAgICAgYXZlcmFnZUN1c3RvbWVyVmFsdWUsXHJcbiAgICAgIGNvbnZlcnNpb25UcmVuZHNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENsZWFyIGFsbCBkYXRhIChmb3IgdGVzdGluZylcclxuICBjbGVhcigpOiB2b2lkIHtcclxuICAgIHRoaXMucHJlZGljdGlvbnMgPSBbXVxyXG4gICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoKVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBub3RpZnlMaXN0ZW5lcnMoKTogdm9pZCB7XHJcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRBbmFseXRpY3NEYXRhKClcclxuICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZGF0YSkpXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgcHJlZGljdGlvbnMgZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZVxyXG4gIGdldFByZWRpY3Rpb25zSW5SYW5nZShzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpOiBQcmVkaWN0aW9uUmVjb3JkW10ge1xyXG4gICAgcmV0dXJuIHRoaXMucHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gXHJcbiAgICAgIHAudGltZXN0YW1wID49IHN0YXJ0RGF0ZSAmJiBwLnRpbWVzdGFtcCA8PSBlbmREYXRlXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgc2VnbWVudCBwZXJmb3JtYW5jZSBtZXRyaWNzXHJcbiAgZ2V0U2VnbWVudE1ldHJpY3Moc2VnbWVudElkOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHNlZ21lbnRQcmVkaWN0aW9ucyA9IHRoaXMucHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gcC5wcmVkaWN0aW9uLmNsdXN0ZXIgPT09IHNlZ21lbnRJZClcclxuICAgIFxyXG4gICAgaWYgKHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhdmdDb25maWRlbmNlID0gc2VnbWVudFByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnByZWRpY3Rpb24uY29uZmlkZW5jZSwgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoXHJcbiAgICBjb25zdCBhdmdTcGVuZGluZyA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEudG90YWxTcGVuZGluZywgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoXHJcbiAgICBjb25zdCBhdmdJbmNvbWUgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLmluY29tZSwgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoXHJcbiAgICBjb25zdCBhdmdBZ2UgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLmFnZSwgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY291bnQ6IHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgIGF2Z0NvbmZpZGVuY2UsXHJcbiAgICAgIGF2Z1NwZW5kaW5nLFxyXG4gICAgICBhdmdJbmNvbWUsXHJcbiAgICAgIGF2Z0FnZSxcclxuICAgICAgcmVjZW50UHJlZGljdGlvbnM6IHNlZ21lbnRQcmVkaWN0aW9ucy5zbGljZSgtNSlcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIFNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgYW5hbHl0aWNzU3RvcmUgPSBuZXcgQW5hbHl0aWNzU3RvcmUoKSJdLCJuYW1lcyI6WyJBbmFseXRpY3NTdG9yZSIsImFkZFByZWRpY3Rpb24iLCJjdXN0b21lckRhdGEiLCJwcmVkaWN0aW9uIiwicmVjb3JkIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyIiwidGltZXN0YW1wIiwiY29uZmlkZW5jZSIsIm1hdGNoU2NvcmUiLCJwcmVkaWN0aW9ucyIsInB1c2giLCJsZW5ndGgiLCJzbGljZSIsIm5vdGlmeUxpc3RlbmVycyIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwibGlzdGVuZXJzIiwiYWRkIiwiZ2V0QW5hbHl0aWNzRGF0YSIsImRlbGV0ZSIsInRvZGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJ0b2RheVByZWRpY3Rpb25zIiwiZmlsdGVyIiwicCIsInNlZ21lbnRDb3VudHMiLCJmb3JFYWNoIiwiY2x1c3RlciIsImhvdXJseVByZWRpY3Rpb25zIiwiQXJyYXkiLCJmcm9tIiwiXyIsImhvdXIiLCJob3VyU3RhcnQiLCJzZXRIb3VycyIsImhvdXJFbmQiLCJjb3VudCIsInNlZ21lbnROYW1lcyIsInRvcFNlZ21lbnRzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsInNlZ21lbnQiLCJwYXJzZUludCIsIm5hbWUiLCJwZXJjZW50YWdlIiwic29ydCIsImEiLCJiIiwiY29udmVyc2lvblRyZW5kcyIsInNlZ21lbnRQcmVkaWN0aW9ucyIsImF2Z1NwZW5kaW5nIiwicmVkdWNlIiwic3VtIiwidG90YWxTcGVuZGluZyIsImF2Z0luY29tZSIsImluY29tZSIsImF2ZXJhZ2VDb25maWRlbmNlIiwiYXZlcmFnZUN1c3RvbWVyVmFsdWUiLCJ0b3RhbFByZWRpY3Rpb25zIiwicHJlZGljdGlvbnNUb2RheSIsInNlZ21lbnREaXN0cmlidXRpb24iLCJjbGVhciIsImRhdGEiLCJnZXRQcmVkaWN0aW9uc0luUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZ2V0U2VnbWVudE1ldHJpY3MiLCJzZWdtZW50SWQiLCJhdmdDb25maWRlbmNlIiwiYXZnQWdlIiwiYWdlIiwicmVjZW50UHJlZGljdGlvbnMiLCJTZXQiLCJhbmFseXRpY3NTdG9yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics-store.ts\n"));

/***/ })

});