"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/analytics-store.ts":
/*!********************************!*\
  !*** ./lib/analytics-store.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyticsStore: function() { return /* binding */ analyticsStore; }\n/* harmony export */ });\n// Analytics store for tracking real predictions and generating insights\nclass AnalyticsStore {\n    // Add a new prediction record\n    addPrediction(customerData, prediction) {\n        const record = {\n            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n            timestamp: new Date(),\n            customerData,\n            prediction: {\n                ...prediction,\n                confidence: prediction.matchScore || Math.random() * 20 + 80 // 80-100% confidence\n            }\n        };\n        this.predictions.push(record);\n        // Keep only last 1000 predictions for performance\n        if (this.predictions.length > 1000) {\n            this.predictions = this.predictions.slice(-1000);\n        }\n        // Notify listeners\n        this.notifyListeners();\n        // Generate activity events\n        this.generateActivityEvents(record);\n    }\n    // Subscribe to analytics updates\n    subscribe(callback) {\n        this.listeners.add(callback);\n        // Send initial data\n        callback(this.getAnalyticsData());\n        // Return unsubscribe function\n        return ()=>{\n            this.listeners.delete(callback);\n        };\n    }\n    // Get current analytics data\n    getAnalyticsData() {\n        const now = new Date();\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        // Filter predictions for today\n        const todayPredictions = this.predictions.filter((p)=>p.timestamp >= today);\n        // Calculate segment distribution\n        const segmentCounts = {};\n        this.predictions.forEach((p)=>{\n            segmentCounts[p.prediction.cluster] = (segmentCounts[p.prediction.cluster] || 0) + 1;\n        });\n        // Calculate hourly predictions for today\n        const hourlyPredictions = Array.from({\n            length: 24\n        }, (_, hour)=>{\n            const hourStart = new Date(today);\n            hourStart.setHours(hour);\n            const hourEnd = new Date(hourStart);\n            hourEnd.setHours(hour + 1);\n            const count = todayPredictions.filter((p)=>p.timestamp >= hourStart && p.timestamp < hourEnd).length;\n            return {\n                hour,\n                count\n            };\n        });\n        // Calculate top segments\n        const segmentNames = {\n            0: \"High-Value Loyal\",\n            1: \"Budget-Conscious\",\n            2: \"Senior Customers\",\n            3: \"Active Balanced\",\n            4: \"Premium\",\n            5: \"Moderate\"\n        };\n        const topSegments = Object.entries(segmentCounts).map((param)=>{\n            let [segment, count] = param;\n            return {\n                segment: parseInt(segment),\n                name: segmentNames[parseInt(segment)] || \"Segment \".concat(segment),\n                count,\n                percentage: count / this.predictions.length * 100\n            };\n        }).sort((a, b)=>b.count - a.count);\n        // Calculate conversion trends\n        const conversionTrends = topSegments.map((segment)=>{\n            const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segment.segment);\n            const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length || 0;\n            const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length || 0;\n            return {\n                segment: segment.segment,\n                avgSpending,\n                avgIncome\n            };\n        });\n        // Calculate average confidence\n        const averageConfidence = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / this.predictions.length : 0;\n        // Calculate average customer value\n        const averageCustomerValue = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / this.predictions.length : 0;\n        return {\n            totalPredictions: this.predictions.length,\n            predictionsToday: todayPredictions.length,\n            averageConfidence,\n            segmentDistribution: segmentCounts,\n            hourlyPredictions,\n            topSegments,\n            averageCustomerValue,\n            conversionTrends,\n            recentActivity: this.getRecentActivity()\n        };\n    }\n    // Generate activity events based on predictions\n    generateActivityEvents(record) {\n        const activities = [];\n        // High confidence prediction\n        if (record.prediction.confidence > 95) {\n            activities.push({\n                id: \"high_conf_\".concat(record.id),\n                type: \"high_confidence\",\n                message: \"High confidence prediction: \".concat(record.prediction.clusterName, \" (\").concat(record.prediction.confidence.toFixed(1), \"%)\"),\n                timestamp: record.timestamp,\n                severity: \"success\"\n            });\n        }\n        // High value customer detected\n        if (record.customerData.totalSpending > 3000 || record.customerData.income > 100000) {\n            activities.push({\n                id: \"high_value_\".concat(record.id),\n                type: \"prediction\",\n                message: \"High-value customer detected: \".concat(record.prediction.clusterName, \" segment\"),\n                timestamp: record.timestamp,\n                severity: \"warning\"\n            });\n        }\n        // Premium segment detection\n        if (record.prediction.cluster === 4) {\n            activities.push({\n                id: \"premium_\".concat(record.id),\n                type: \"segment_trend\",\n                message: \"Premium customer identified with \".concat(record.customerData.totalSpending.toLocaleString(), \" spending\"),\n                timestamp: record.timestamp,\n                severity: \"success\"\n            });\n        }\n        // Regular prediction activity\n        activities.push({\n            id: \"pred_\".concat(record.id),\n            type: \"prediction\",\n            message: \"Customer classified as \".concat(record.prediction.clusterName),\n            timestamp: record.timestamp,\n            severity: \"info\"\n        });\n        // Store activities (keep last 50)\n        this.recentActivities.push(...activities);\n        if (this.recentActivities.length > 50) {\n            this.recentActivities = this.recentActivities.slice(-50);\n        }\n    }\n    getRecentActivity() {\n        return this.recentActivities.sort((a, b)=>b.timestamp.getTime() - a.timestamp.getTime()).slice(0, 10);\n    }\n    notifyListeners() {\n        const data = this.getAnalyticsData();\n        this.listeners.forEach((callback)=>callback(data));\n    }\n    // Get predictions for a specific time range\n    getPredictionsInRange(startDate, endDate) {\n        return this.predictions.filter((p)=>p.timestamp >= startDate && p.timestamp <= endDate);\n    }\n    // Get segment performance metrics\n    getSegmentMetrics(segmentId) {\n        const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segmentId);\n        if (segmentPredictions.length === 0) {\n            return null;\n        }\n        const avgConfidence = segmentPredictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / segmentPredictions.length;\n        const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length;\n        const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length;\n        const avgAge = segmentPredictions.reduce((sum, p)=>sum + p.customerData.age, 0) / segmentPredictions.length;\n        return {\n            count: segmentPredictions.length,\n            avgConfidence,\n            avgSpending,\n            avgIncome,\n            avgAge,\n            recentPredictions: segmentPredictions.slice(-5)\n        };\n    }\n    // Clear all data (for testing)\n    clear() {\n        this.predictions = [];\n        this.recentActivities = [];\n        this.notifyListeners();\n    }\n    constructor(){\n        this.predictions = [];\n        this.listeners = new Set();\n        this.recentActivities = [];\n    }\n}\n// Singleton instance\nconst analyticsStore = new AnalyticsStore();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hbmFseXRpY3Mtc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdFQUF3RTtBQWtDeEUsTUFBTUE7SUFJSiw4QkFBOEI7SUFDOUJDLGNBQWNDLFlBQWlCLEVBQUVDLFVBQWUsRUFBUTtRQUN0RCxNQUFNQyxTQUEyQjtZQUMvQkMsSUFBSUMsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLEtBQUtDLEtBQUtDLE1BQU0sR0FBR0YsUUFBUSxDQUFDLElBQUlHLE1BQU0sQ0FBQyxHQUFHO1lBQ2pFQyxXQUFXLElBQUlOO1lBQ2ZKO1lBQ0FDLFlBQVk7Z0JBQ1YsR0FBR0EsVUFBVTtnQkFDYlUsWUFBWVYsV0FBV1csVUFBVSxJQUFJTCxLQUFLQyxNQUFNLEtBQUssS0FBSyxHQUFHLHFCQUFxQjtZQUNwRjtRQUNGO1FBRUEsSUFBSSxDQUFDSyxXQUFXLENBQUNDLElBQUksQ0FBQ1o7UUFFdEIsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDVyxXQUFXLENBQUNFLE1BQU0sR0FBRyxNQUFNO1lBQ2xDLElBQUksQ0FBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDRyxLQUFLLENBQUMsQ0FBQztRQUM3QztRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNDLGVBQWU7UUFFcEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNoQjtJQUM5QjtJQUVBLGlDQUFpQztJQUNqQ2lCLFVBQVVDLFFBQXVDLEVBQWM7UUFDN0QsSUFBSSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQ0Y7UUFFbkIsb0JBQW9CO1FBQ3BCQSxTQUFTLElBQUksQ0FBQ0csZ0JBQWdCO1FBRTlCLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDRixTQUFTLENBQUNHLE1BQU0sQ0FBQ0o7UUFDeEI7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QkcsbUJBQWtDO1FBQ2hDLE1BQU1sQixNQUFNLElBQUlEO1FBQ2hCLE1BQU1xQixRQUFR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QW1CaEMsbUJBQW1CekMsS0FBSyxDQUFDLENBQUM7UUFDL0M7SUFDRjtJQUVBLCtCQUErQjtJQUMvQjBFLFFBQWM7UUFDWixJQUFJLENBQUM3RSxXQUFXLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUNpRSxnQkFBZ0IsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQzdELGVBQWU7SUFDdEI7O2FBbE9RSixjQUFrQyxFQUFFO2FBQ3BDUSxZQUFnRCxJQUFJc0U7YUFpTHBEYixtQkFBb0QsRUFBRTs7QUFpRGhFO0FBRUEscUJBQXFCO0FBQ2QsTUFBTWMsaUJBQWlCLElBQUk5RixpQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FuYWx5dGljcy1zdG9yZS50cz9lNzMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFuYWx5dGljcyBzdG9yZSBmb3IgdHJhY2tpbmcgcmVhbCBwcmVkaWN0aW9ucyBhbmQgZ2VuZXJhdGluZyBpbnNpZ2h0c1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQcmVkaWN0aW9uUmVjb3JkIHtcclxuICBpZDogc3RyaW5nXHJcbiAgdGltZXN0YW1wOiBEYXRlXHJcbiAgY3VzdG9tZXJEYXRhOiB7XHJcbiAgICBhZ2U6IG51bWJlclxyXG4gICAgaW5jb21lOiBudW1iZXJcclxuICAgIHRvdGFsU3BlbmRpbmc6IG51bWJlclxyXG4gICAgcmVjZW5jeTogbnVtYmVyXHJcbiAgICBjdXN0b21lclNpbmNlOiBudW1iZXJcclxuICAgIG51bVdlYlB1cmNoYXNlczogbnVtYmVyXHJcbiAgICBudW1TdG9yZVB1cmNoYXNlczogbnVtYmVyXHJcbiAgICBudW1XZWJWaXNpdHNNb250aDogbnVtYmVyXHJcbiAgfVxyXG4gIHByZWRpY3Rpb246IHtcclxuICAgIGNsdXN0ZXI6IG51bWJlclxyXG4gICAgY2x1c3Rlck5hbWU6IHN0cmluZ1xyXG4gICAgbWF0Y2hTY29yZTogbnVtYmVyXHJcbiAgICBjb25maWRlbmNlOiBudW1iZXJcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQW5hbHl0aWNzRGF0YSB7XHJcbiAgdG90YWxQcmVkaWN0aW9uczogbnVtYmVyXHJcbiAgcHJlZGljdGlvbnNUb2RheTogbnVtYmVyXHJcbiAgYXZlcmFnZUNvbmZpZGVuY2U6IG51bWJlclxyXG4gIHNlZ21lbnREaXN0cmlidXRpb246IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH1cclxuICBob3VybHlQcmVkaWN0aW9uczogeyBob3VyOiBudW1iZXI7IGNvdW50OiBudW1iZXIgfVtdXHJcbiAgdG9wU2VnbWVudHM6IHsgc2VnbWVudDogbnVtYmVyOyBuYW1lOiBzdHJpbmc7IGNvdW50OiBudW1iZXI7IHBlcmNlbnRhZ2U6IG51bWJlciB9W11cclxuICBhdmVyYWdlQ3VzdG9tZXJWYWx1ZTogbnVtYmVyXHJcbiAgY29udmVyc2lvblRyZW5kczogeyBzZWdtZW50OiBudW1iZXI7IGF2Z1NwZW5kaW5nOiBudW1iZXI7IGF2Z0luY29tZTogbnVtYmVyIH1bXVxyXG59XHJcblxyXG5jbGFzcyBBbmFseXRpY3NTdG9yZSB7XHJcbiAgcHJpdmF0ZSBwcmVkaWN0aW9uczogUHJlZGljdGlvblJlY29yZFtdID0gW11cclxuICBwcml2YXRlIGxpc3RlbmVyczogU2V0PChkYXRhOiBBbmFseXRpY3NEYXRhKSA9PiB2b2lkPiA9IG5ldyBTZXQoKVxyXG5cclxuICAvLyBBZGQgYSBuZXcgcHJlZGljdGlvbiByZWNvcmRcclxuICBhZGRQcmVkaWN0aW9uKGN1c3RvbWVyRGF0YTogYW55LCBwcmVkaWN0aW9uOiBhbnkpOiB2b2lkIHtcclxuICAgIGNvbnN0IHJlY29yZDogUHJlZGljdGlvblJlY29yZCA9IHtcclxuICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcclxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICBjdXN0b21lckRhdGEsXHJcbiAgICAgIHByZWRpY3Rpb246IHtcclxuICAgICAgICAuLi5wcmVkaWN0aW9uLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6IHByZWRpY3Rpb24ubWF0Y2hTY29yZSB8fCBNYXRoLnJhbmRvbSgpICogMjAgKyA4MCAvLyA4MC0xMDAlIGNvbmZpZGVuY2VcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJlZGljdGlvbnMucHVzaChyZWNvcmQpXHJcbiAgICBcclxuICAgIC8vIEtlZXAgb25seSBsYXN0IDEwMDAgcHJlZGljdGlvbnMgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICBpZiAodGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPiAxMDAwKSB7XHJcbiAgICAgIHRoaXMucHJlZGljdGlvbnMgPSB0aGlzLnByZWRpY3Rpb25zLnNsaWNlKC0xMDAwKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnNcclxuICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKClcclxuICAgIFxyXG4gICAgLy8gR2VuZXJhdGUgYWN0aXZpdHkgZXZlbnRzXHJcbiAgICB0aGlzLmdlbmVyYXRlQWN0aXZpdHlFdmVudHMocmVjb3JkKVxyXG4gIH1cclxuXHJcbiAgLy8gU3Vic2NyaWJlIHRvIGFuYWx5dGljcyB1cGRhdGVzXHJcbiAgc3Vic2NyaWJlKGNhbGxiYWNrOiAoZGF0YTogQW5hbHl0aWNzRGF0YSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xyXG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGNhbGxiYWNrKVxyXG4gICAgXHJcbiAgICAvLyBTZW5kIGluaXRpYWwgZGF0YVxyXG4gICAgY2FsbGJhY2sodGhpcy5nZXRBbmFseXRpY3NEYXRhKCkpXHJcbiAgICBcclxuICAgIC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGN1cnJlbnQgYW5hbHl0aWNzIGRhdGFcclxuICBnZXRBbmFseXRpY3NEYXRhKCk6IEFuYWx5dGljc0RhdGEge1xyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZShub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCkpXHJcbiAgICBcclxuICAgIC8vIEZpbHRlciBwcmVkaWN0aW9ucyBmb3IgdG9kYXlcclxuICAgIGNvbnN0IHRvZGF5UHJlZGljdGlvbnMgPSB0aGlzLnByZWRpY3Rpb25zLmZpbHRlcihwID0+IHAudGltZXN0YW1wID49IHRvZGF5KVxyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgc2VnbWVudCBkaXN0cmlidXRpb25cclxuICAgIGNvbnN0IHNlZ21lbnRDb3VudHM6IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH0gPSB7fVxyXG4gICAgdGhpcy5wcmVkaWN0aW9ucy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICBzZWdtZW50Q291bnRzW3AucHJlZGljdGlvbi5jbHVzdGVyXSA9IChzZWdtZW50Q291bnRzW3AucHJlZGljdGlvbi5jbHVzdGVyXSB8fCAwKSArIDFcclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGhvdXJseSBwcmVkaWN0aW9ucyBmb3IgdG9kYXlcclxuICAgIGNvbnN0IGhvdXJseVByZWRpY3Rpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjQgfSwgKF8sIGhvdXIpID0+IHtcclxuICAgICAgY29uc3QgaG91clN0YXJ0ID0gbmV3IERhdGUodG9kYXkpXHJcbiAgICAgIGhvdXJTdGFydC5zZXRIb3Vycyhob3VyKVxyXG4gICAgICBjb25zdCBob3VyRW5kID0gbmV3IERhdGUoaG91clN0YXJ0KVxyXG4gICAgICBob3VyRW5kLnNldEhvdXJzKGhvdXIgKyAxKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgY291bnQgPSB0b2RheVByZWRpY3Rpb25zLmZpbHRlcihwID0+IFxyXG4gICAgICAgIHAudGltZXN0YW1wID49IGhvdXJTdGFydCAmJiBwLnRpbWVzdGFtcCA8IGhvdXJFbmRcclxuICAgICAgKS5sZW5ndGhcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7IGhvdXIsIGNvdW50IH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRvcCBzZWdtZW50c1xyXG4gICAgY29uc3Qgc2VnbWVudE5hbWVzID0ge1xyXG4gICAgICAwOiBcIkhpZ2gtVmFsdWUgTG95YWxcIixcclxuICAgICAgMTogXCJCdWRnZXQtQ29uc2Npb3VzXCIsIFxyXG4gICAgICAyOiBcIlNlbmlvciBDdXN0b21lcnNcIixcclxuICAgICAgMzogXCJBY3RpdmUgQmFsYW5jZWRcIixcclxuICAgICAgNDogXCJQcmVtaXVtXCIsXHJcbiAgICAgIDU6IFwiTW9kZXJhdGVcIlxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvcFNlZ21lbnRzID0gT2JqZWN0LmVudHJpZXMoc2VnbWVudENvdW50cylcclxuICAgICAgLm1hcCgoW3NlZ21lbnQsIGNvdW50XSkgPT4gKHtcclxuICAgICAgICBzZWdtZW50OiBwYXJzZUludChzZWdtZW50KSxcclxuICAgICAgICBuYW1lOiBzZWdtZW50TmFtZXNbcGFyc2VJbnQoc2VnbWVudCkgYXMga2V5b2YgdHlwZW9mIHNlZ21lbnROYW1lc10gfHwgYFNlZ21lbnQgJHtzZWdtZW50fWAsXHJcbiAgICAgICAgY291bnQsXHJcbiAgICAgICAgcGVyY2VudGFnZTogKGNvdW50IC8gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGgpICogMTAwXHJcbiAgICAgIH0pKVxyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5jb3VudCAtIGEuY291bnQpXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvbnZlcnNpb24gdHJlbmRzXHJcbiAgICBjb25zdCBjb252ZXJzaW9uVHJlbmRzID0gdG9wU2VnbWVudHMubWFwKHNlZ21lbnQgPT4ge1xyXG4gICAgICBjb25zdCBzZWdtZW50UHJlZGljdGlvbnMgPSB0aGlzLnByZWRpY3Rpb25zLmZpbHRlcihwID0+IHAucHJlZGljdGlvbi5jbHVzdGVyID09PSBzZWdtZW50LnNlZ21lbnQpXHJcbiAgICAgIGNvbnN0IGF2Z1NwZW5kaW5nID0gc2VnbWVudFByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmN1c3RvbWVyRGF0YS50b3RhbFNwZW5kaW5nLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGggfHwgMFxyXG4gICAgICBjb25zdCBhdmdJbmNvbWUgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLmluY29tZSwgMCkgLyBzZWdtZW50UHJlZGljdGlvbnMubGVuZ3RoIHx8IDBcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VnbWVudDogc2VnbWVudC5zZWdtZW50LFxyXG4gICAgICAgIGF2Z1NwZW5kaW5nLFxyXG4gICAgICAgIGF2Z0luY29tZVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGNvbmZpZGVuY2VcclxuICAgIGNvbnN0IGF2ZXJhZ2VDb25maWRlbmNlID0gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPiAwIFxyXG4gICAgICA/IHRoaXMucHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAucHJlZGljdGlvbi5jb25maWRlbmNlLCAwKSAvIHRoaXMucHJlZGljdGlvbnMubGVuZ3RoXHJcbiAgICAgIDogMFxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGN1c3RvbWVyIHZhbHVlXHJcbiAgICBjb25zdCBhdmVyYWdlQ3VzdG9tZXJWYWx1ZSA9IHRoaXMucHJlZGljdGlvbnMubGVuZ3RoID4gMFxyXG4gICAgICA/IHRoaXMucHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLnRvdGFsU3BlbmRpbmcsIDApIC8gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgICAgOiAwXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxQcmVkaWN0aW9uczogdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgIHByZWRpY3Rpb25zVG9kYXk6IHRvZGF5UHJlZGljdGlvbnMubGVuZ3RoLFxyXG4gICAgICBhdmVyYWdlQ29uZmlkZW5jZSxcclxuICAgICAgc2VnbWVudERpc3RyaWJ1dGlvbjogc2VnbWVudENvdW50cyxcclxuICAgICAgaG91cmx5UHJlZGljdGlvbnMsXHJcbiAgICAgIHRvcFNlZ21lbnRzLFxyXG4gICAgICBhdmVyYWdlQ3VzdG9tZXJWYWx1ZSxcclxuICAgICAgY29udmVyc2lvblRyZW5kcyxcclxuICAgICAgcmVjZW50QWN0aXZpdHk6IHRoaXMuZ2V0UmVjZW50QWN0aXZpdHkoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gR2VuZXJhdGUgYWN0aXZpdHkgZXZlbnRzIGJhc2VkIG9uIHByZWRpY3Rpb25zXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZUFjdGl2aXR5RXZlbnRzKHJlY29yZDogUHJlZGljdGlvblJlY29yZCk6IHZvaWQge1xyXG4gICAgY29uc3QgYWN0aXZpdGllcyA9IFtdXHJcblxyXG4gICAgLy8gSGlnaCBjb25maWRlbmNlIHByZWRpY3Rpb25cclxuICAgIGlmIChyZWNvcmQucHJlZGljdGlvbi5jb25maWRlbmNlID4gOTUpIHtcclxuICAgICAgYWN0aXZpdGllcy5wdXNoKHtcclxuICAgICAgICBpZDogYGhpZ2hfY29uZl8ke3JlY29yZC5pZH1gLFxyXG4gICAgICAgIHR5cGU6ICdoaWdoX2NvbmZpZGVuY2UnIGFzIGNvbnN0LFxyXG4gICAgICAgIG1lc3NhZ2U6IGBIaWdoIGNvbmZpZGVuY2UgcHJlZGljdGlvbjogJHtyZWNvcmQucHJlZGljdGlvbi5jbHVzdGVyTmFtZX0gKCR7cmVjb3JkLnByZWRpY3Rpb24uY29uZmlkZW5jZS50b0ZpeGVkKDEpfSUpYCxcclxuICAgICAgICB0aW1lc3RhbXA6IHJlY29yZC50aW1lc3RhbXAsXHJcbiAgICAgICAgc2V2ZXJpdHk6ICdzdWNjZXNzJyBhcyBjb25zdFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhpZ2ggdmFsdWUgY3VzdG9tZXIgZGV0ZWN0ZWRcclxuICAgIGlmIChyZWNvcmQuY3VzdG9tZXJEYXRhLnRvdGFsU3BlbmRpbmcgPiAzMDAwIHx8IHJlY29yZC5jdXN0b21lckRhdGEuaW5jb21lID4gMTAwMDAwKSB7XHJcbiAgICAgIGFjdGl2aXRpZXMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGBoaWdoX3ZhbHVlXyR7cmVjb3JkLmlkfWAsXHJcbiAgICAgICAgdHlwZTogJ3ByZWRpY3Rpb24nIGFzIGNvbnN0LFxyXG4gICAgICAgIG1lc3NhZ2U6IGBIaWdoLXZhbHVlIGN1c3RvbWVyIGRldGVjdGVkOiAke3JlY29yZC5wcmVkaWN0aW9uLmNsdXN0ZXJOYW1lfSBzZWdtZW50YCxcclxuICAgICAgICB0aW1lc3RhbXA6IHJlY29yZC50aW1lc3RhbXAsXHJcbiAgICAgICAgc2V2ZXJpdHk6ICd3YXJuaW5nJyBhcyBjb25zdFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZW1pdW0gc2VnbWVudCBkZXRlY3Rpb25cclxuICAgIGlmIChyZWNvcmQucHJlZGljdGlvbi5jbHVzdGVyID09PSA0KSB7XHJcbiAgICAgIGFjdGl2aXRpZXMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGBwcmVtaXVtXyR7cmVjb3JkLmlkfWAsXHJcbiAgICAgICAgdHlwZTogJ3NlZ21lbnRfdHJlbmQnIGFzIGNvbnN0LFxyXG4gICAgICAgIG1lc3NhZ2U6IGBQcmVtaXVtIGN1c3RvbWVyIGlkZW50aWZpZWQgd2l0aCAke3JlY29yZC5jdXN0b21lckRhdGEudG90YWxTcGVuZGluZy50b0xvY2FsZVN0cmluZygpfSBzcGVuZGluZ2AsXHJcbiAgICAgICAgdGltZXN0YW1wOiByZWNvcmQudGltZXN0YW1wLFxyXG4gICAgICAgIHNldmVyaXR5OiAnc3VjY2VzcycgYXMgY29uc3RcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWd1bGFyIHByZWRpY3Rpb24gYWN0aXZpdHlcclxuICAgIGFjdGl2aXRpZXMucHVzaCh7XHJcbiAgICAgIGlkOiBgcHJlZF8ke3JlY29yZC5pZH1gLFxyXG4gICAgICB0eXBlOiAncHJlZGljdGlvbicgYXMgY29uc3QsXHJcbiAgICAgIG1lc3NhZ2U6IGBDdXN0b21lciBjbGFzc2lmaWVkIGFzICR7cmVjb3JkLnByZWRpY3Rpb24uY2x1c3Rlck5hbWV9YCxcclxuICAgICAgdGltZXN0YW1wOiByZWNvcmQudGltZXN0YW1wLFxyXG4gICAgICBzZXZlcml0eTogJ2luZm8nIGFzIGNvbnN0XHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFN0b3JlIGFjdGl2aXRpZXMgKGtlZXAgbGFzdCA1MClcclxuICAgIHRoaXMucmVjZW50QWN0aXZpdGllcy5wdXNoKC4uLmFjdGl2aXRpZXMpXHJcbiAgICBpZiAodGhpcy5yZWNlbnRBY3Rpdml0aWVzLmxlbmd0aCA+IDUwKSB7XHJcbiAgICAgIHRoaXMucmVjZW50QWN0aXZpdGllcyA9IHRoaXMucmVjZW50QWN0aXZpdGllcy5zbGljZSgtNTApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlY2VudEFjdGl2aXRpZXM6IEFuYWx5dGljc0RhdGFbJ3JlY2VudEFjdGl2aXR5J10gPSBbXVxyXG5cclxuICBwcml2YXRlIGdldFJlY2VudEFjdGl2aXR5KCk6IEFuYWx5dGljc0RhdGFbJ3JlY2VudEFjdGl2aXR5J10ge1xyXG4gICAgcmV0dXJuIHRoaXMucmVjZW50QWN0aXZpdGllc1xyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKVxyXG4gICAgICAuc2xpY2UoMCwgMTApXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG5vdGlmeUxpc3RlbmVycygpOiB2b2lkIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEFuYWx5dGljc0RhdGEoKVxyXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhkYXRhKSlcclxuICB9XHJcblxyXG4gIC8vIEdldCBwcmVkaWN0aW9ucyBmb3IgYSBzcGVjaWZpYyB0aW1lIHJhbmdlXHJcbiAgZ2V0UHJlZGljdGlvbnNJblJhbmdlKHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IFByZWRpY3Rpb25SZWNvcmRbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBcclxuICAgICAgcC50aW1lc3RhbXAgPj0gc3RhcnREYXRlICYmIHAudGltZXN0YW1wIDw9IGVuZERhdGVcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8vIEdldCBzZWdtZW50IHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICBnZXRTZWdtZW50TWV0cmljcyhzZWdtZW50SWQ6IG51bWJlcikge1xyXG4gICAgY29uc3Qgc2VnbWVudFByZWRpY3Rpb25zID0gdGhpcy5wcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBwLnByZWRpY3Rpb24uY2x1c3RlciA9PT0gc2VnbWVudElkKVxyXG4gICAgXHJcbiAgICBpZiAoc2VnbWVudFByZWRpY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGF2Z0NvbmZpZGVuY2UgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAucHJlZGljdGlvbi5jb25maWRlbmNlLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgIGNvbnN0IGF2Z1NwZW5kaW5nID0gc2VnbWVudFByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmN1c3RvbWVyRGF0YS50b3RhbFNwZW5kaW5nLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgIGNvbnN0IGF2Z0luY29tZSA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEuaW5jb21lLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgIGNvbnN0IGF2Z0FnZSA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEuYWdlLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb3VudDogc2VnbWVudFByZWRpY3Rpb25zLmxlbmd0aCxcclxuICAgICAgYXZnQ29uZmlkZW5jZSxcclxuICAgICAgYXZnU3BlbmRpbmcsXHJcbiAgICAgIGF2Z0luY29tZSxcclxuICAgICAgYXZnQWdlLFxyXG4gICAgICByZWNlbnRQcmVkaWN0aW9uczogc2VnbWVudFByZWRpY3Rpb25zLnNsaWNlKC01KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYXIgYWxsIGRhdGEgKGZvciB0ZXN0aW5nKVxyXG4gIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgdGhpcy5wcmVkaWN0aW9ucyA9IFtdXHJcbiAgICB0aGlzLnJlY2VudEFjdGl2aXRpZXMgPSBbXVxyXG4gICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoKVxyXG4gIH1cclxufVxyXG5cclxuLy8gU2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBhbmFseXRpY3NTdG9yZSA9IG5ldyBBbmFseXRpY3NTdG9yZSgpIl0sIm5hbWVzIjpbIkFuYWx5dGljc1N0b3JlIiwiYWRkUHJlZGljdGlvbiIsImN1c3RvbWVyRGF0YSIsInByZWRpY3Rpb24iLCJyZWNvcmQiLCJpZCIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJ0aW1lc3RhbXAiLCJjb25maWRlbmNlIiwibWF0Y2hTY29yZSIsInByZWRpY3Rpb25zIiwicHVzaCIsImxlbmd0aCIsInNsaWNlIiwibm90aWZ5TGlzdGVuZXJzIiwiZ2VuZXJhdGVBY3Rpdml0eUV2ZW50cyIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwibGlzdGVuZXJzIiwiYWRkIiwiZ2V0QW5hbHl0aWNzRGF0YSIsImRlbGV0ZSIsInRvZGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJ0b2RheVByZWRpY3Rpb25zIiwiZmlsdGVyIiwicCIsInNlZ21lbnRDb3VudHMiLCJmb3JFYWNoIiwiY2x1c3RlciIsImhvdXJseVByZWRpY3Rpb25zIiwiQXJyYXkiLCJmcm9tIiwiXyIsImhvdXIiLCJob3VyU3RhcnQiLCJzZXRIb3VycyIsImhvdXJFbmQiLCJjb3VudCIsInNlZ21lbnROYW1lcyIsInRvcFNlZ21lbnRzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsInNlZ21lbnQiLCJwYXJzZUludCIsIm5hbWUiLCJwZXJjZW50YWdlIiwic29ydCIsImEiLCJiIiwiY29udmVyc2lvblRyZW5kcyIsInNlZ21lbnRQcmVkaWN0aW9ucyIsImF2Z1NwZW5kaW5nIiwicmVkdWNlIiwic3VtIiwidG90YWxTcGVuZGluZyIsImF2Z0luY29tZSIsImluY29tZSIsImF2ZXJhZ2VDb25maWRlbmNlIiwiYXZlcmFnZUN1c3RvbWVyVmFsdWUiLCJ0b3RhbFByZWRpY3Rpb25zIiwicHJlZGljdGlvbnNUb2RheSIsInNlZ21lbnREaXN0cmlidXRpb24iLCJyZWNlbnRBY3Rpdml0eSIsImdldFJlY2VudEFjdGl2aXR5IiwiYWN0aXZpdGllcyIsInR5cGUiLCJtZXNzYWdlIiwiY2x1c3Rlck5hbWUiLCJ0b0ZpeGVkIiwic2V2ZXJpdHkiLCJ0b0xvY2FsZVN0cmluZyIsInJlY2VudEFjdGl2aXRpZXMiLCJnZXRUaW1lIiwiZGF0YSIsImdldFByZWRpY3Rpb25zSW5SYW5nZSIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJnZXRTZWdtZW50TWV0cmljcyIsInNlZ21lbnRJZCIsImF2Z0NvbmZpZGVuY2UiLCJhdmdBZ2UiLCJhZ2UiLCJyZWNlbnRQcmVkaWN0aW9ucyIsImNsZWFyIiwiU2V0IiwiYW5hbHl0aWNzU3RvcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics-store.ts\n"));

/***/ })

});