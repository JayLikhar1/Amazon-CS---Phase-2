"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/analytics-store.ts":
/*!********************************!*\
  !*** ./lib/analytics-store.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyticsStore: function() { return /* binding */ analyticsStore; }\n/* harmony export */ });\n// Analytics store for tracking real predictions and generating insights\nclass AnalyticsStore {\n    // Add a new prediction record\n    addPrediction(customerData, prediction) {\n        const record = {\n            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n            timestamp: new Date(),\n            customerData,\n            prediction: {\n                ...prediction,\n                confidence: prediction.matchScore || Math.random() * 20 + 80 // 80-100% confidence\n            }\n        };\n        this.predictions.push(record);\n        // Keep only last 1000 predictions for performance\n        if (this.predictions.length > 1000) {\n            this.predictions = this.predictions.slice(-1000);\n        }\n        // Notify listeners\n        this.notifyListeners();\n    }\n    // Subscribe to analytics updates\n    subscribe(callback) {\n        this.listeners.add(callback);\n        // Send initial data\n        callback(this.getAnalyticsData());\n        // Return unsubscribe function\n        return ()=>{\n            this.listeners.delete(callback);\n        };\n    }\n    // Get current analytics data\n    getAnalyticsData() {\n        const now = new Date();\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n        // Filter predictions for today\n        const todayPredictions = this.predictions.filter((p)=>p.timestamp >= today);\n        // Calculate segment distribution\n        const segmentCounts = {};\n        this.predictions.forEach((p)=>{\n            segmentCounts[p.prediction.cluster] = (segmentCounts[p.prediction.cluster] || 0) + 1;\n        });\n        // Calculate hourly predictions for today\n        const hourlyPredictions = Array.from({\n            length: 24\n        }, (_, hour)=>{\n            const hourStart = new Date(today);\n            hourStart.setHours(hour);\n            const hourEnd = new Date(hourStart);\n            hourEnd.setHours(hour + 1);\n            const count = todayPredictions.filter((p)=>p.timestamp >= hourStart && p.timestamp < hourEnd).length;\n            return {\n                hour,\n                count\n            };\n        });\n        // Calculate top segments\n        const segmentNames = {\n            0: \"High-Value Loyal\",\n            1: \"Budget-Conscious\",\n            2: \"Senior Customers\",\n            3: \"Active Balanced\",\n            4: \"Premium\",\n            5: \"Moderate\"\n        };\n        const topSegments = Object.entries(segmentCounts).map((param)=>{\n            let [segment, count] = param;\n            return {\n                segment: parseInt(segment),\n                name: segmentNames[parseInt(segment)] || \"Segment \".concat(segment),\n                count,\n                percentage: count / this.predictions.length * 100\n            };\n        }).sort((a, b)=>b.count - a.count);\n        // Calculate conversion trends\n        const conversionTrends = topSegments.map((segment)=>{\n            const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segment.segment);\n            const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length || 0;\n            const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length || 0;\n            return {\n                segment: segment.segment,\n                avgSpending,\n                avgIncome\n            };\n        });\n        // Calculate average confidence\n        const averageConfidence = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / this.predictions.length : 0;\n        // Calculate average customer value\n        const averageCustomerValue = this.predictions.length > 0 ? this.predictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / this.predictions.length : 0;\n        return {\n            totalPredictions: this.predictions.length,\n            predictionsToday: todayPredictions.length,\n            averageConfidence,\n            segmentDistribution: segmentCounts,\n            hourlyPredictions,\n            topSegments,\n            averageCustomerValue,\n            conversionTrends\n        };\n    }\n    notifyListeners() {\n        const data = this.getAnalyticsData();\n        this.listeners.forEach((callback)=>callback(data));\n    }\n    // Get predictions for a specific time range\n    getPredictionsInRange(startDate, endDate) {\n        return this.predictions.filter((p)=>p.timestamp >= startDate && p.timestamp <= endDate);\n    }\n    // Get segment performance metrics\n    getSegmentMetrics(segmentId) {\n        const segmentPredictions = this.predictions.filter((p)=>p.prediction.cluster === segmentId);\n        if (segmentPredictions.length === 0) {\n            return null;\n        }\n        const avgConfidence = segmentPredictions.reduce((sum, p)=>sum + p.prediction.confidence, 0) / segmentPredictions.length;\n        const avgSpending = segmentPredictions.reduce((sum, p)=>sum + p.customerData.totalSpending, 0) / segmentPredictions.length;\n        const avgIncome = segmentPredictions.reduce((sum, p)=>sum + p.customerData.income, 0) / segmentPredictions.length;\n        const avgAge = segmentPredictions.reduce((sum, p)=>sum + p.customerData.age, 0) / segmentPredictions.length;\n        return {\n            count: segmentPredictions.length,\n            avgConfidence,\n            avgSpending,\n            avgIncome,\n            avgAge,\n            recentPredictions: segmentPredictions.slice(-5)\n        };\n    }\n    constructor(){\n        this.predictions = [];\n        this.listeners = new Set();\n    }\n}\n// Singleton instance\nconst analyticsStore = new AnalyticsStore();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hbmFseXRpY3Mtc3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdFQUF3RTtBQWtDeEUsTUFBTUE7SUFJSiw4QkFBOEI7SUFDOUJDLGNBQWNDLFlBQWlCLEVBQUVDLFVBQWUsRUFBUTtRQUN0RCxNQUFNQyxTQUEyQjtZQUMvQkMsSUFBSUMsS0FBS0MsR0FBRyxHQUFHQyxRQUFRLEtBQUtDLEtBQUtDLE1BQU0sR0FBR0YsUUFBUSxDQUFDLElBQUlHLE1BQU0sQ0FBQyxHQUFHO1lBQ2pFQyxXQUFXLElBQUlOO1lBQ2ZKO1lBQ0FDLFlBQVk7Z0JBQ1YsR0FBR0EsVUFBVTtnQkFDYlUsWUFBWVYsV0FBV1csVUFBVSxJQUFJTCxLQUFLQyxNQUFNLEtBQUssS0FBSyxHQUFHLHFCQUFxQjtZQUNwRjtRQUNGO1FBRUEsSUFBSSxDQUFDSyxXQUFXLENBQUNDLElBQUksQ0FBQ1o7UUFFdEIsa0RBQWtEO1FBQ2xELElBQUksSUFBSSxDQUFDVyxXQUFXLENBQUNFLE1BQU0sR0FBRyxNQUFNO1lBQ2xDLElBQUksQ0FBQ0YsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDRyxLQUFLLENBQUMsQ0FBQztRQUM3QztRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNDLGVBQWU7SUFDdEI7SUFFQSxpQ0FBaUM7SUFDakNDLFVBQVVDLFFBQXVDLEVBQWM7UUFDN0QsSUFBSSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQ0Y7UUFFbkIsb0JBQW9CO1FBQ3BCQSxTQUFTLElBQUksQ0FBQ0csZ0JBQWdCO1FBRTlCLDhCQUE4QjtRQUM5QixPQUFPO1lBQ0wsSUFBSSxDQUFDRixTQUFTLENBQUNHLE1BQU0sQ0FBQ0o7UUFDeEI7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QkcsbUJBQWtDO1FBQ2hDLE1BQU1qQixNQUFNLElBQUlEO1FBQ2hCLE1BQU1vQixRQUFRLElBQUlwQixLQUFLQyxJQUFJb0IsV0FBVyxJQUFJcEIsSUFBSXFCLFFBQVEs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S0osbUJBQW1CekMsTUFBTTtRQUM1SCxNQUFNOEMsWUFBWUwsbUJBQW1CRSxNQUFNLENBQUMsQ0FBQ0MsS0FBSzdCLElBQU02QixNQUFNN0IsRUFBRTlCLFlBQVksQ0FBQzhELE1BQU0sRUFBRSxLQUFLTixtQkFBbUJ6QyxNQUFNO1FBQ25ILE1BQU00RCxTQUFTbkIsbUJBQW1CRSxNQUFNLENBQUMsQ0FBQ0MsS0FBSzdCLElBQU02QixNQUFNN0IsRUFBRTlCLFlBQVksQ0FBQzRFLEdBQUcsRUFBRSxLQUFLcEIsbUJBQW1CekMsTUFBTTtRQUU3RyxPQUFPO1lBQ0wyQixPQUFPYyxtQkFBbUJ6QyxNQUFNO1lBQ2hDMkQ7WUFDQWpCO1lBQ0FJO1lBQ0FjO1lBQ0FFLG1CQUFtQnJCLG1CQUFtQnhDLEtBQUssQ0FBQyxDQUFDO1FBQy9DO0lBQ0Y7O2FBMUpRSCxjQUFrQyxFQUFFO2FBQ3BDTyxZQUFnRCxJQUFJMEQ7O0FBMEo5RDtBQUVBLHFCQUFxQjtBQUNkLE1BQU1DLGlCQUFpQixJQUFJakYsaUJBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hbmFseXRpY3Mtc3RvcmUudHM/ZTczMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBbmFseXRpY3Mgc3RvcmUgZm9yIHRyYWNraW5nIHJlYWwgcHJlZGljdGlvbnMgYW5kIGdlbmVyYXRpbmcgaW5zaWdodHNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJlZGljdGlvblJlY29yZCB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHRpbWVzdGFtcDogRGF0ZVxyXG4gIGN1c3RvbWVyRGF0YToge1xyXG4gICAgYWdlOiBudW1iZXJcclxuICAgIGluY29tZTogbnVtYmVyXHJcbiAgICB0b3RhbFNwZW5kaW5nOiBudW1iZXJcclxuICAgIHJlY2VuY3k6IG51bWJlclxyXG4gICAgY3VzdG9tZXJTaW5jZTogbnVtYmVyXHJcbiAgICBudW1XZWJQdXJjaGFzZXM6IG51bWJlclxyXG4gICAgbnVtU3RvcmVQdXJjaGFzZXM6IG51bWJlclxyXG4gICAgbnVtV2ViVmlzaXRzTW9udGg6IG51bWJlclxyXG4gIH1cclxuICBwcmVkaWN0aW9uOiB7XHJcbiAgICBjbHVzdGVyOiBudW1iZXJcclxuICAgIGNsdXN0ZXJOYW1lOiBzdHJpbmdcclxuICAgIG1hdGNoU2NvcmU6IG51bWJlclxyXG4gICAgY29uZmlkZW5jZTogbnVtYmVyXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5dGljc0RhdGEge1xyXG4gIHRvdGFsUHJlZGljdGlvbnM6IG51bWJlclxyXG4gIHByZWRpY3Rpb25zVG9kYXk6IG51bWJlclxyXG4gIGF2ZXJhZ2VDb25maWRlbmNlOiBudW1iZXJcclxuICBzZWdtZW50RGlzdHJpYnV0aW9uOiB7IFtrZXk6IG51bWJlcl06IG51bWJlciB9XHJcbiAgaG91cmx5UHJlZGljdGlvbnM6IHsgaG91cjogbnVtYmVyOyBjb3VudDogbnVtYmVyIH1bXVxyXG4gIHRvcFNlZ21lbnRzOiB7IHNlZ21lbnQ6IG51bWJlcjsgbmFtZTogc3RyaW5nOyBjb3VudDogbnVtYmVyOyBwZXJjZW50YWdlOiBudW1iZXIgfVtdXHJcbiAgYXZlcmFnZUN1c3RvbWVyVmFsdWU6IG51bWJlclxyXG4gIGNvbnZlcnNpb25UcmVuZHM6IHsgc2VnbWVudDogbnVtYmVyOyBhdmdTcGVuZGluZzogbnVtYmVyOyBhdmdJbmNvbWU6IG51bWJlciB9W11cclxufVxyXG5cclxuY2xhc3MgQW5hbHl0aWNzU3RvcmUge1xyXG4gIHByaXZhdGUgcHJlZGljdGlvbnM6IFByZWRpY3Rpb25SZWNvcmRbXSA9IFtdXHJcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IFNldDwoZGF0YTogQW5hbHl0aWNzRGF0YSkgPT4gdm9pZD4gPSBuZXcgU2V0KClcclxuXHJcbiAgLy8gQWRkIGEgbmV3IHByZWRpY3Rpb24gcmVjb3JkXHJcbiAgYWRkUHJlZGljdGlvbihjdXN0b21lckRhdGE6IGFueSwgcHJlZGljdGlvbjogYW55KTogdm9pZCB7XHJcbiAgICBjb25zdCByZWNvcmQ6IFByZWRpY3Rpb25SZWNvcmQgPSB7XHJcbiAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSksXHJcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgY3VzdG9tZXJEYXRhLFxyXG4gICAgICBwcmVkaWN0aW9uOiB7XHJcbiAgICAgICAgLi4ucHJlZGljdGlvbixcclxuICAgICAgICBjb25maWRlbmNlOiBwcmVkaWN0aW9uLm1hdGNoU2NvcmUgfHwgTWF0aC5yYW5kb20oKSAqIDIwICsgODAgLy8gODAtMTAwJSBjb25maWRlbmNlXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnByZWRpY3Rpb25zLnB1c2gocmVjb3JkKVxyXG4gICAgXHJcbiAgICAvLyBLZWVwIG9ubHkgbGFzdCAxMDAwIHByZWRpY3Rpb25zIGZvciBwZXJmb3JtYW5jZVxyXG4gICAgaWYgKHRoaXMucHJlZGljdGlvbnMubGVuZ3RoID4gMTAwMCkge1xyXG4gICAgICB0aGlzLnByZWRpY3Rpb25zID0gdGhpcy5wcmVkaWN0aW9ucy5zbGljZSgtMTAwMClcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RpZnkgbGlzdGVuZXJzXHJcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygpXHJcbiAgfVxyXG5cclxuICAvLyBTdWJzY3JpYmUgdG8gYW5hbHl0aWNzIHVwZGF0ZXNcclxuICBzdWJzY3JpYmUoY2FsbGJhY2s6IChkYXRhOiBBbmFseXRpY3NEYXRhKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoY2FsbGJhY2spXHJcbiAgICBcclxuICAgIC8vIFNlbmQgaW5pdGlhbCBkYXRhXHJcbiAgICBjYWxsYmFjayh0aGlzLmdldEFuYWx5dGljc0RhdGEoKSlcclxuICAgIFxyXG4gICAgLy8gUmV0dXJuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgY3VycmVudCBhbmFseXRpY3MgZGF0YVxyXG4gIGdldEFuYWx5dGljc0RhdGEoKTogQW5hbHl0aWNzRGF0YSB7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKSlcclxuICAgIFxyXG4gICAgLy8gRmlsdGVyIHByZWRpY3Rpb25zIGZvciB0b2RheVxyXG4gICAgY29uc3QgdG9kYXlQcmVkaWN0aW9ucyA9IHRoaXMucHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gcC50aW1lc3RhbXAgPj0gdG9kYXkpXHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBzZWdtZW50IGRpc3RyaWJ1dGlvblxyXG4gICAgY29uc3Qgc2VnbWVudENvdW50czogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfSA9IHt9XHJcbiAgICB0aGlzLnByZWRpY3Rpb25zLmZvckVhY2gocCA9PiB7XHJcbiAgICAgIHNlZ21lbnRDb3VudHNbcC5wcmVkaWN0aW9uLmNsdXN0ZXJdID0gKHNlZ21lbnRDb3VudHNbcC5wcmVkaWN0aW9uLmNsdXN0ZXJdIHx8IDApICsgMVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgaG91cmx5IHByZWRpY3Rpb25zIGZvciB0b2RheVxyXG4gICAgY29uc3QgaG91cmx5UHJlZGljdGlvbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNCB9LCAoXywgaG91cikgPT4ge1xyXG4gICAgICBjb25zdCBob3VyU3RhcnQgPSBuZXcgRGF0ZSh0b2RheSlcclxuICAgICAgaG91clN0YXJ0LnNldEhvdXJzKGhvdXIpXHJcbiAgICAgIGNvbnN0IGhvdXJFbmQgPSBuZXcgRGF0ZShob3VyU3RhcnQpXHJcbiAgICAgIGhvdXJFbmQuc2V0SG91cnMoaG91ciArIDEpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb3VudCA9IHRvZGF5UHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gXHJcbiAgICAgICAgcC50aW1lc3RhbXAgPj0gaG91clN0YXJ0ICYmIHAudGltZXN0YW1wIDwgaG91ckVuZFxyXG4gICAgICApLmxlbmd0aFxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHsgaG91ciwgY291bnQgfVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdG9wIHNlZ21lbnRzXHJcbiAgICBjb25zdCBzZWdtZW50TmFtZXMgPSB7XHJcbiAgICAgIDA6IFwiSGlnaC1WYWx1ZSBMb3lhbFwiLFxyXG4gICAgICAxOiBcIkJ1ZGdldC1Db25zY2lvdXNcIiwgXHJcbiAgICAgIDI6IFwiU2VuaW9yIEN1c3RvbWVyc1wiLFxyXG4gICAgICAzOiBcIkFjdGl2ZSBCYWxhbmNlZFwiLFxyXG4gICAgICA0OiBcIlByZW1pdW1cIixcclxuICAgICAgNTogXCJNb2RlcmF0ZVwiXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdG9wU2VnbWVudHMgPSBPYmplY3QuZW50cmllcyhzZWdtZW50Q291bnRzKVxyXG4gICAgICAubWFwKChbc2VnbWVudCwgY291bnRdKSA9PiAoe1xyXG4gICAgICAgIHNlZ21lbnQ6IHBhcnNlSW50KHNlZ21lbnQpLFxyXG4gICAgICAgIG5hbWU6IHNlZ21lbnROYW1lc1twYXJzZUludChzZWdtZW50KSBhcyBrZXlvZiB0eXBlb2Ygc2VnbWVudE5hbWVzXSB8fCBgU2VnbWVudCAke3NlZ21lbnR9YCxcclxuICAgICAgICBjb3VudCxcclxuICAgICAgICBwZXJjZW50YWdlOiAoY291bnQgLyB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCkgKiAxMDBcclxuICAgICAgfSkpXHJcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudClcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgY29udmVyc2lvbiB0cmVuZHNcclxuICAgIGNvbnN0IGNvbnZlcnNpb25UcmVuZHMgPSB0b3BTZWdtZW50cy5tYXAoc2VnbWVudCA9PiB7XHJcbiAgICAgIGNvbnN0IHNlZ21lbnRQcmVkaWN0aW9ucyA9IHRoaXMucHJlZGljdGlvbnMuZmlsdGVyKHAgPT4gcC5wcmVkaWN0aW9uLmNsdXN0ZXIgPT09IHNlZ21lbnQuc2VnbWVudClcclxuICAgICAgY29uc3QgYXZnU3BlbmRpbmcgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY3VzdG9tZXJEYXRhLnRvdGFsU3BlbmRpbmcsIDApIC8gc2VnbWVudFByZWRpY3Rpb25zLmxlbmd0aCB8fCAwXHJcbiAgICAgIGNvbnN0IGF2Z0luY29tZSA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEuaW5jb21lLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGggfHwgMFxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzZWdtZW50OiBzZWdtZW50LnNlZ21lbnQsXHJcbiAgICAgICAgYXZnU3BlbmRpbmcsXHJcbiAgICAgICAgYXZnSW5jb21lXHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgY29uZmlkZW5jZVxyXG4gICAgY29uc3QgYXZlcmFnZUNvbmZpZGVuY2UgPSB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCA+IDAgXHJcbiAgICAgID8gdGhpcy5wcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5wcmVkaWN0aW9uLmNvbmZpZGVuY2UsIDApIC8gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgICAgOiAwXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgY3VzdG9tZXIgdmFsdWVcclxuICAgIGNvbnN0IGF2ZXJhZ2VDdXN0b21lclZhbHVlID0gdGhpcy5wcmVkaWN0aW9ucy5sZW5ndGggPiAwXHJcbiAgICAgID8gdGhpcy5wcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEudG90YWxTcGVuZGluZywgMCkgLyB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aFxyXG4gICAgICA6IDBcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbFByZWRpY3Rpb25zOiB0aGlzLnByZWRpY3Rpb25zLmxlbmd0aCxcclxuICAgICAgcHJlZGljdGlvbnNUb2RheTogdG9kYXlQcmVkaWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgIGF2ZXJhZ2VDb25maWRlbmNlLFxyXG4gICAgICBzZWdtZW50RGlzdHJpYnV0aW9uOiBzZWdtZW50Q291bnRzLFxyXG4gICAgICBob3VybHlQcmVkaWN0aW9ucyxcclxuICAgICAgdG9wU2VnbWVudHMsXHJcbiAgICAgIGF2ZXJhZ2VDdXN0b21lclZhbHVlLFxyXG4gICAgICBjb252ZXJzaW9uVHJlbmRzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG5vdGlmeUxpc3RlbmVycygpOiB2b2lkIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEFuYWx5dGljc0RhdGEoKVxyXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhkYXRhKSlcclxuICB9XHJcblxyXG4gIC8vIEdldCBwcmVkaWN0aW9ucyBmb3IgYSBzcGVjaWZpYyB0aW1lIHJhbmdlXHJcbiAgZ2V0UHJlZGljdGlvbnNJblJhbmdlKHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IFByZWRpY3Rpb25SZWNvcmRbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBcclxuICAgICAgcC50aW1lc3RhbXAgPj0gc3RhcnREYXRlICYmIHAudGltZXN0YW1wIDw9IGVuZERhdGVcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8vIEdldCBzZWdtZW50IHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICBnZXRTZWdtZW50TWV0cmljcyhzZWdtZW50SWQ6IG51bWJlcikge1xyXG4gICAgY29uc3Qgc2VnbWVudFByZWRpY3Rpb25zID0gdGhpcy5wcmVkaWN0aW9ucy5maWx0ZXIocCA9PiBwLnByZWRpY3Rpb24uY2x1c3RlciA9PT0gc2VnbWVudElkKVxyXG4gICAgXHJcbiAgICBpZiAoc2VnbWVudFByZWRpY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGF2Z0NvbmZpZGVuY2UgPSBzZWdtZW50UHJlZGljdGlvbnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAucHJlZGljdGlvbi5jb25maWRlbmNlLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgIGNvbnN0IGF2Z1NwZW5kaW5nID0gc2VnbWVudFByZWRpY3Rpb25zLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLmN1c3RvbWVyRGF0YS50b3RhbFNwZW5kaW5nLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgIGNvbnN0IGF2Z0luY29tZSA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEuaW5jb21lLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuICAgIGNvbnN0IGF2Z0FnZSA9IHNlZ21lbnRQcmVkaWN0aW9ucy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcC5jdXN0b21lckRhdGEuYWdlLCAwKSAvIHNlZ21lbnRQcmVkaWN0aW9ucy5sZW5ndGhcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb3VudDogc2VnbWVudFByZWRpY3Rpb25zLmxlbmd0aCxcclxuICAgICAgYXZnQ29uZmlkZW5jZSxcclxuICAgICAgYXZnU3BlbmRpbmcsXHJcbiAgICAgIGF2Z0luY29tZSxcclxuICAgICAgYXZnQWdlLFxyXG4gICAgICByZWNlbnRQcmVkaWN0aW9uczogc2VnbWVudFByZWRpY3Rpb25zLnNsaWNlKC01KVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gU2luZ2xldG9uIGluc3RhbmNlXHJcbmV4cG9ydCBjb25zdCBhbmFseXRpY3NTdG9yZSA9IG5ldyBBbmFseXRpY3NTdG9yZSgpIl0sIm5hbWVzIjpbIkFuYWx5dGljc1N0b3JlIiwiYWRkUHJlZGljdGlvbiIsImN1c3RvbWVyRGF0YSIsInByZWRpY3Rpb24iLCJyZWNvcmQiLCJpZCIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJ0aW1lc3RhbXAiLCJjb25maWRlbmNlIiwibWF0Y2hTY29yZSIsInByZWRpY3Rpb25zIiwicHVzaCIsImxlbmd0aCIsInNsaWNlIiwibm90aWZ5TGlzdGVuZXJzIiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJsaXN0ZW5lcnMiLCJhZGQiLCJnZXRBbmFseXRpY3NEYXRhIiwiZGVsZXRlIiwidG9kYXkiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsInRvZGF5UHJlZGljdGlvbnMiLCJmaWx0ZXIiLCJwIiwic2VnbWVudENvdW50cyIsImZvckVhY2giLCJjbHVzdGVyIiwiaG91cmx5UHJlZGljdGlvbnMiLCJBcnJheSIsImZyb20iLCJfIiwiaG91ciIsImhvdXJTdGFydCIsInNldEhvdXJzIiwiaG91ckVuZCIsImNvdW50Iiwic2VnbWVudE5hbWVzIiwidG9wU2VnbWVudHMiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwic2VnbWVudCIsInBhcnNlSW50IiwibmFtZSIsInBlcmNlbnRhZ2UiLCJzb3J0IiwiYSIsImIiLCJjb252ZXJzaW9uVHJlbmRzIiwic2VnbWVudFByZWRpY3Rpb25zIiwiYXZnU3BlbmRpbmciLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbFNwZW5kaW5nIiwiYXZnSW5jb21lIiwiaW5jb21lIiwiYXZlcmFnZUNvbmZpZGVuY2UiLCJhdmVyYWdlQ3VzdG9tZXJWYWx1ZSIsInRvdGFsUHJlZGljdGlvbnMiLCJwcmVkaWN0aW9uc1RvZGF5Iiwic2VnbWVudERpc3RyaWJ1dGlvbiIsImRhdGEiLCJnZXRQcmVkaWN0aW9uc0luUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiZ2V0U2VnbWVudE1ldHJpY3MiLCJzZWdtZW50SWQiLCJhdmdDb25maWRlbmNlIiwiYXZnQWdlIiwiYWdlIiwicmVjZW50UHJlZGljdGlvbnMiLCJTZXQiLCJhbmFseXRpY3NTdG9yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics-store.ts\n"));

/***/ })

});